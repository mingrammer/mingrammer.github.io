<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">

		
		<meta property="og:title" content="[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI" />
<meta property="og:description" content="Building Blockchain in Go 시리즈를 번역한 글입니다. 서론 우리는 지금까지 채굴이 가능한 작업 증명 시스템을 지닌 블록체인을 구현했다. 좀 더 완벽한 기능을 갖춘 블록체인에 가까워지" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mingrammer.com/building-blockchain-in-go-part-3/" />
<meta property="article:published_time" content="2018-05-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-05-22T00:00:00+00:00" />

		

		<meta name="generator" content="Hugo 0.69.0" />
		<title>[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
		<link rel="stylesheet" href="https://mingrammer.com/css/custom.css">
		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [Go로 구현하는 블록체인] Part 3: 영속성 및 CLI
                    </h1>
                    <h2 class="headline">
                    May 22, 2018 00:00
                    · 4631 words
                    · 10 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/blockchain">blockchain</a>
                          
                              <a href="https://mingrammer.com/tags/persistence">persistence</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
  <ul>
    <li><a href="#서론">서론</a></li>
    <li><a href="#데이터베이스-선택">데이터베이스 선택</a></li>
    <li><a href="#boltdb">BoltDB</a></li>
    <li><a href="#데이터베이스-구조">데이터베이스 구조</a></li>
    <li><a href="#직렬화">직렬화</a></li>
    <li><a href="#영속성">영속성</a></li>
    <li><a href="#블록체인-탐색">블록체인 탐색</a></li>
    <li><a href="#cli">CLI</a></li>
    <li><a href="#결론">결론</a></li>
  </ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <blockquote>
<p><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-3">Building Blockchain in Go</a> 시리즈를 번역한 글입니다.</p>
</blockquote>
<h1 id="서론">서론</h1>
<p>우리는 <a href="/building-blockchain-in-go-part-2">지금까지</a> 채굴이 가능한 작업 증명 시스템을 지닌 블록체인을 구현했다. 좀 더 완벽한 기능을 갖춘 블록체인에 가까워지고 있지만 여전히 일부 중요한 기능들이 부족하다. 이번 파트에서는 블록체인을 데이터베이스에 저장하고 블록체인 연산을 수행하기 위한 간단한 커맨드라인 툴을 만들어 볼 것이다. 블록체인은 본질적으로 데이터베이스이다. 지금은 &ldquo;분산 (distributed)&ldquo;부분을 생략하고 &ldquo;데이터베이스&quot;부분에 집중할 것이다.</p>
<h1 id="데이터베이스-선택">데이터베이스 선택</h1>
<p>지금까지 구현한 블록체인에는 데이터베이스가 없기 때문에 매번 프로그램을 실행할때마다 블록을 생성하여 메모리에 저장하고 있다. 따라서 블록체인을 재사용할 수 없으며 다른 사람들과도 공유할 수 없기 때문에 이를 디스크에 저장해야할 필요가 있다.</p>
<p>그렇다면 어떤 데이터베이스가 필요할까? 사실 아무거나 써도된다. <a href="https://bitcoin.org/bitcoin.pdf">비트코인 논문</a>에서도 특정 데이터베이스에 대한 언급은 없으며 이는 개발자의 선택에 달렸다. 사토시 나카모토가 초창기에 배포하고 현재 비트코인 구현체의 레퍼런스로 있는 <a href="https://github.com/bitcoin/bitcoin">비트코인 코어</a>에서는 <a href="https://github.com/google/leveldb">LevelDB</a> (물론 이는 2012년에만 도입되었지만)를 사용한다. 그리고 우리는 다음 데이터베이스를 사용할 것이다.</p>
<h1 id="boltdb">BoltDB</h1>
<p>BoltDB를 사용하는 이유는 다음과 같다.</p>
<ol>
<li>단순하고 가볍다.</li>
<li>Go로 작성되었다.</li>
<li>별도의 서버가 필요하지 않다.</li>
<li>데이터 구조 설계가 자유롭다.</li>
</ol>
<p>BoltDB의 <a href="https://github.com/boltdb/bolt">Github README.md</a>에 따르면</p>
<blockquote>
<p>Bolt는 Howard Chu의 LMDB 프로젝트에서 영감을 받아 순수 Go로 작성된 키/값 스토어이다. 이는 Postgres나 MySQL과 같이 데이터베이스 서버가 필요하지 않은 프로젝트를 위해 간단하고 빠르며 안정적인 데이터베이스를 제공하고자 만들어졌다.</p>
<p>Bolt는 저수준의 기능으로 사용되기 때문에 단순함이 중요하다. API가 적으며 값을 얻고 설정하는데에만 초점을 맞추고 있다. 이게 끝이다.</p>
</blockquote>
<p>우리의 요구사항에 완벽히 들어맞는다! 조금만 더 살펴보자.</p>
<p>BoltDB는 키/값 스토리지로 SQL RDBMS (MySQL, PostgreSQL등)와 같은 테이블과 행 및 열이 필요없음을 의미한다. 대신 데이터는 Go에서의 map과 같이 키-값의 쌍으로 저장된다. 키-값 쌍은 유사한 쌍을 그룹화 하기위한 버킷에 저장된다 (이는 RDBMS에서의 테이블과 유사하다). 따라서 값을 가져오려면 버킷과 키 모두 알아야한다.</p>
<p>BoltDB에서 한가지 중요한 점은 데이터 타입이 없다는 것이다. 키와 값은 바이트 배열로 저장된다. 우리는 Go 구조체 (특히 <strong>Block</strong>)를 저장할 것이기 때문에 직렬화가 필요하다. Go 구조체를 바이트 배열로 변환하고 바이트 배열로부터 구조체를 복원하는 메커니즘을 구현해야한다. 우리는 <a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>을 사용할 것이다. 이 패키지는 <strong>JSON</strong>, <strong>XML</strong> 및 <strong>Protocol Buffers</strong>와도 사용할 수 있다.</p>
<h1 id="데이터베이스-구조">데이터베이스 구조</h1>
<p>영속성 로직을 구현하기 전에, 우선 DB에 데이터를 저장하는 방식부터 결정해야한다. 비트코인 코어의 방식을 참조해보자.</p>
<p>간단히 말하면 비트코인 코어는 데이터를 저장하기 위해 두 개의 &ldquo;버킷&quot;을 사용한다.</p>
<ol>
<li><strong>blocks</strong>는 체인의 모든 블록을 설명하는 메타데이터를 저장한다.</li>
<li><strong>chainstate</strong>는 체인의 상태를 저장한다. 이 상태는 현재 사용되지 않은 모든 트랙잭션과 일부 메타데이터를 포함한다.</li>
</ol>
<p>또한 블록들은 디스크에 분리된 파일들로 저장된다. 이는 성능 때문인데 하나의 블록을 읽기 위해 전체 혹은 일부 데이터를 메모리에 로드할 필요는 없기 때문이다. 우리는 이 부분은 구현하지 않을 것이다.</p>
<p><strong>block</strong>에는 다음과 같은 <strong>키-&gt;값</strong> 쌍들이 있다.</p>
<ol>
<li><strong>&lsquo;b&rsquo; + 32바이트 블록 해시 -&gt; 블록 인덱스 레코드</strong></li>
<li><strong>&lsquo;f&rsquo; + 4바이트 파일 번호 -&gt; 파일 정보 레코드</strong></li>
<li><strong>&lsquo;l&rsquo; -&gt; 4바이트 파일 번호: 마지막으로 사용된 블록의 파일 번호</strong></li>
<li><strong>&lsquo;R&rsquo; -&gt; 1바이트 부울: 재색인 작업 진행 여부</strong></li>
<li><strong>&lsquo;F&rsquo; + 1바이트 플래그명 길이 + 플래그명 -&gt; 1바이트 부울: 끄고 켤 수 있는 여러 플래그들</strong></li>
<li><strong>&lsquo;t&rsquo; + 32바이트 트랙잭션 해시 -&gt; 트랜잭션 인덱스 레코드</strong></li>
</ol>
<p><strong>chainstate</strong>에는 다음과 같은 <strong>키-&gt;값</strong> 쌍들이 있다.</p>
<ol>
<li><strong>&lsquo;c&rsquo; + 32바이트 트랜잭션 해시 -&gt; 해당 트랜잭션에 대한 미사용 트랜잭션 출력 레코드</strong></li>
<li><strong>&lsquo;B&rsquo; -&gt; 32바이트 블록 해시: 데이터베이스가 미사용 트랜잭션 출력을 나타내는 블록 해시</strong></li>
</ol>
<p><em>(자세한 설명은 <a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_%28ch_2%29:_Data_Storage">여기</a>에서 볼 수 있다)</em></p>
<p>우리에겐 아직 트랜잭션이 없기 때문에 <strong>blocks</strong> 버킷만 가질 것이다. 또한 앞서 언급했듯이 우리는 블록들을 여러 파일에 저장하지 않고 전체 DB를 하나의 파일로 저장할 것이다. 따라서 우리는 파일 번호와 관련된 데이터는 필요하지 않다. 따라서 우리가 사용할 키-값 쌍은 다음과 같다.</p>
<ol>
<li><strong>32바이트 블록 해시 -&gt; 직렬화된 블록 구조체</strong></li>
<li><strong>&lsquo;l&rsquo; -&gt; 체인의 마지막 블록의 해시</strong></li>
</ol>
<p>이제 영속성 메커니즘을 구현하는데 필요한 것들을 모두 살펴보았다.</p>
<h1 id="직렬화">직렬화</h1>
<p>이전에도 말했듯이 BoltDB에서는**[]byte** 타입의 값만 사용할 수 있으며 우리는 DB에 **Block** 구조체를 저장하려고 한다. 우리는 구조체 직렬화에 <a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>을 사용할 것이다.</p>
<p><strong>Block</strong>의 <strong>Serialize</strong> 메서드를 구현해보자. (단순한 구현을 위해 에러 처리는 생략한다)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Block</span><span class="p">)</span> <span class="nf">Serialize</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">result</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>

        <span class="nx">encoder</span> <span class="o">:=</span> <span class="nx">gob</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">)</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encoder</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>아주 직관적인 코드로, 우선 직렬화된 데이터를 저장할 버퍼를 선언하고 <strong>gob</strong> 인코더를 초기화 한 뒤 블록을 인코딩하면 바이트 배열이 반환된다.</p>
<p>다음으로 바이트 배열을 받아 <strong>Block</strong>을 반환하는 역직렬화 함수가 필요하다. 이는 메서드가 아닌 독립적인 함수로 구현한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DeserializeBlock</span><span class="p">(</span><span class="nx">d</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">Block</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">block</span> <span class="nx">Block</span>

        <span class="nx">decoder</span> <span class="o">:=</span> <span class="nx">gob</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">decoder</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">block</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">*</span><span class="nx">block</span>
<span class="p">}</span>
</code></pre></div><p>직렬화 관련 작업이 끝났다!</p>
<h1 id="영속성">영속성</h1>
<p>이제 <strong>NewBlockchain</strong> 함수를 살펴보자. 이 함수는 현재 새로운 <strong>Blockchain</strong> 인스턴스를 생성하고 여기에 제네시스 블록을 추가하고 있다. 우리가 원하는 기능은 다음과 같다.</p>
<ol>
<li>DB 파일을 연다.</li>
<li>저장된 블록체인이 있는지 확인한다.</li>
<li>블록체인이 존재하면
<ol>
<li>새로운 <strong>Blockchain</strong> 인스턴스를 생성한다.</li>
<li><strong>Blockchain</strong> 인스턴스의 끝부분을 DB에 저장된 마지막 블록의 해시로 설정한다.</li>
</ol>
</li>
<li>블록체인이 존재하지 않으면
<ol>
<li>제네시스 블록을 생성한다.</li>
<li>DB에 저장한다.</li>
<li>제네시스 블록의 해시를 마지막 블록의 해시로 저장한다.</li>
<li>제네시스 블록을 끝부분으로 하는 새로운 <strong>Blockchain</strong> 인스턴스를 생성한다.</li>
</ol>
</li>
</ol>
<p>코드로보면 다음과 같다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewBlockchain</span><span class="p">()</span> <span class="o">*</span><span class="nx">Blockchain</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">tip</span> <span class="p">[]</span><span class="kt">byte</span>
        <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bolt</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">dbFile</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

        <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
                <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nx">genesis</span> <span class="o">:=</span> <span class="nf">NewGenesisBlock</span><span class="p">()</span>
                        <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">CreateBucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
                        <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span><span class="p">,</span> <span class="nx">genesis</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">())</span>
                        <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">),</span> <span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>
                        <span class="nx">tip</span> <span class="p">=</span> <span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nx">tip</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Get</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">})</span>

        <span class="nx">bc</span> <span class="o">:=</span> <span class="nx">Blockchain</span><span class="p">{</span><span class="nx">tip</span><span class="p">,</span> <span class="nx">db</span><span class="p">}</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">bc</span>
<span class="p">}</span>
</code></pre></div><p>한 줄씩 살펴보자.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bolt</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">dbFile</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div><p>이는 BoltDB 파일을 여는 표준 방식이다. 파일이 없어도 오류를 반환하고 있지 않음을 볼 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">})</span>
</code></pre></div><p>BoltDB에서 데이터베이스 연산은 트랜잭션내에서 실행된다. 읽기 전용과 읽기-쓰기의 두 가지 타입의 트랜잭션이 있다. 위 코드에서는 DB에 제네시스 블록을 써넣을수도 있기 때문에 읽기-쓰기 트랜잭션 (<strong>db.Update(&hellip;)</strong>)을 연다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">genesis</span> <span class="o">:=</span> <span class="nf">NewGenesisBlock</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">CreateBucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span><span class="p">,</span> <span class="nx">genesis</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">())</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">),</span> <span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>
        <span class="nx">tip</span> <span class="p">=</span> <span class="nx">genesis</span><span class="p">.</span><span class="nx">Hash</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">tip</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Get</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>이 코드는 함수의 핵심이다. 블록을 저장하고 있는 버킷을 가져와 버킷이 존재하면 <strong>l</strong> 키를 읽고 존재하지 않으면 제네시스 블록을 생성하고, 버킷을 만들어 블록을 저장한뒤 체인의 마지막 블록의 해시를 저장하는 <strong>l</strong> 키를 업데이트한다.</p>
<p>여기서 <strong>Blockchain</strong>을 생성하는 또 다른 방식을 볼 수 있다.</p>
<pre><code>bc := Blockchain{tip, db}
</code></pre><p>더 이상 모든 블록을 저장하지 않고 체인의 끝 블록의 해시만 저장한다. 또한 프로그램이 실행되는동안 한 번 열어둔 데이터베이스를 유지하기 위해 DB 커넥션을 저장한다. 따라서 <strong>Blockchain</strong> 구조체는 다음과 같아진다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Blockchain</span> <span class="kd">struct</span> <span class="p">{</span>
    	<span class="nx">tip</span> <span class="p">[]</span><span class="kt">byte</span>
    	<span class="nx">db</span>  <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">DB</span>
<span class="p">}</span>
</code></pre></div><p>다음으로 수정할 메서드는 <strong>AddBlock</strong> 메서드이다. 이제 체인에 블록을 추가하는건 배열에 원소를 추가하는 것만큼 쉽지않다. 지금부터는 블록을 DB에 저장할 것이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="nf">AddBlock</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">lastHash</span> <span class="p">[]</span><span class="kt">byte</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">View</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
                <span class="nx">lastHash</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Get</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">})</span>

        <span class="nx">newBlock</span> <span class="o">:=</span> <span class="nf">NewBlock</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">lastHash</span><span class="p">)</span>

        <span class="nx">err</span> <span class="p">=</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
                <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">,</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">())</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">),</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>
                <span class="nx">bc</span><span class="p">.</span><span class="nx">tip</span> <span class="p">=</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>한 줄씩 살펴보자.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">View</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
        <span class="nx">lastHash</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Get</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">nil</span>
<span class="p">})</span>
</code></pre></div><p>이는 BoltDB의 읽기 전용 트랜잭션이다. 새로운 블록의 해시를 채굴하기 위해 DB로부터 마지막 블록의 해시값을 가져온다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">newBlock</span> <span class="o">:=</span> <span class="nf">NewBlock</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">lastHash</span><span class="p">)</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">,</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">())</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Put</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">),</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>
<span class="nx">bc</span><span class="p">.</span><span class="nx">tip</span> <span class="p">=</span> <span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span>
</code></pre></div><p>새로운 블록의 채굴이 끝나면 직렬화하여 DB에 저장하고 새로운 블록의 해시를 저장하는 <strong>l</strong> 키를 업데이트한다.</p>
<p>끝났다! 그리 어렵지는 않았다.</p>
<h1 id="블록체인-탐색">블록체인 탐색</h1>
<p>이제 모든 블록을 데이터베이스에 저장하고 있기 때문에 블록체인을 다시 열어 새로운 블록을 추가할 수 있다. 그러나 이를 구현한 뒤로 우리는 멋진 기능 하나를 잃었다. 더 이상 블록을 배열에 저장하고 있지 않기 때문에 블록체인의 블록들을 출력할 수 없다. 이제 이 결함을 수정해보자!</p>
<p>BoltDB는 버킷의 모든 키를 순회할 수 있는 기능을 제공하지만 키들은 바이트 순서로 정렬되어있다. 그러나 우리는 블록체인에 삽입된 순서대로 블록을 출력하고싶다. 또한 (블록체인 DB가 거대해질 수 있으므로) 모든 블록을 메모리에 로드하고 싶지는 않기 때문에 블록들을 하나씩 읽을 것이다. 이를 위해선 블록체인 반복자 (Iterator)가 필요하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BlockchainIterator</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">currentHash</span> <span class="p">[]</span><span class="kt">byte</span>
        <span class="nx">db</span>          <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">DB</span>
<span class="p">}</span>
</code></pre></div><p>반복자는 블록체인의 블록을 반복할때마다 만들어지며 이는 현재 반복의 블록 해시와 DB 커넥션을 저장한다. 블록의 해시와 DB 커넥션이 필요하기 때문에 반복자는 논리적으로 블록체인과 연결되어 있으며 따라서 이는 <strong>Blockchain</strong>의 메서드로 만든다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="nf">Iterator</span><span class="p">()</span> <span class="o">*</span><span class="nx">BlockchainIterator</span> <span class="p">{</span>
        <span class="nx">bci</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">BlockchainIterator</span><span class="p">{</span><span class="nx">bc</span><span class="p">.</span><span class="nx">tip</span><span class="p">,</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">db</span><span class="p">}</span>
        <span class="k">return</span> <span class="nx">bci</span>
<span class="p">}</span>
</code></pre></div><p>반복자는 초기에 블록체인의 끝을 가리킨다. 따라서 블록은 위에서 아래로, 최신 블록부터 오래된 블록의 순서로 얻을 수 있다. 사실 <strong>블록체인의 끝을 선택한다는 것은 블록체인에 대한 &ldquo;투표&quot;를 의미한다</strong> . 블록체인은 여러개의 가지 (브랜치)를 가질 수 있으며 가장 긴 체인이 메인 체인으로 간주된다. 블록체인의 끝을 얻으면 (이는 블록체인의 어느 블록도 가능하다) 전체 블록체인을 재구성하여 체인의 길이와 체인을 만드는데 필요한 작업을 찾을 수 있다.</p>
<p><strong>BlockchainIterator</strong>는 블록체인으로부터 다음 블록을 반환하는 단 한 가지 일만 수행한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">BlockchainIterator</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="o">*</span><span class="nx">Block</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">block</span> <span class="o">*</span><span class="nx">Block</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">View</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">blocksBucket</span><span class="p">))</span>
        	<span class="nx">encodedBlock</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">currentHash</span><span class="p">)</span>
        	<span class="nx">block</span> <span class="p">=</span> <span class="nf">DeserializeBlock</span><span class="p">(</span><span class="nx">encodedBlock</span><span class="p">)</span>
        	<span class="k">return</span> <span class="kc">nil</span>
        <span class="p">})</span>

        <span class="nx">i</span><span class="p">.</span><span class="nx">currentHash</span> <span class="p">=</span> <span class="nx">block</span><span class="p">.</span><span class="nx">PrevBlockHash</span>
        <span class="k">return</span> <span class="nx">block</span>
<span class="p">}</span>
</code></pre></div><p>DB 파트가 끝났다!</p>
<h1 id="cli">CLI</h1>
<p>지금까지 우리가 만든 구현체는 프로그램과 상호 작용할 수 있는 그 어떤 인터페이스도 제공하지 않았다. 우리는 여태 단순히 <strong>main</strong> 함수에서 <strong>NewBlockchain</strong>과 <strong>bc.AddBlock</strong>을 실행시켰었다. 이제 이를 개선해보자! 우리는 다음 명령어들이 필요하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">blockchain_go addblock <span class="s2">&#34;Pay 0.31337 for a coffee&#34;</span>
blockchain_go printchain
</code></pre></div><p>커맨드라인과 관련된 모든 연산들은 <strong>CLI</strong> 구조체에 의해 처리된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CLI</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span>
<span class="p">}</span>
</code></pre></div><p>CLI의 엔트리포인트는 <strong>Run</strong> 함수이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cli</span> <span class="o">*</span><span class="nx">CLI</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nf">validateArgs</span><span class="p">()</span>

        <span class="nx">addBlockCmd</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;addblock&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>
        <span class="nx">printChainCmd</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;printchain&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>
        <span class="nx">addBlockData</span> <span class="o">:=</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;data&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;Block data&#34;</span><span class="p">)</span>

        <span class="k">switch</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">&#34;addblock&#34;</span><span class="p">:</span>
                <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">case</span> <span class="s">&#34;printchain&#34;</span><span class="p">:</span>
                <span class="nx">err</span> <span class="o">:=</span> <span class="nx">printChainCmd</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">default</span><span class="p">:</span>
                <span class="nx">cli</span><span class="p">.</span><span class="nf">printUsage</span><span class="p">()</span>
                <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Parsed</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">*</span><span class="nx">addBlockData</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                        <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Usage</span><span class="p">()</span>
                        <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">cli</span><span class="p">.</span><span class="nf">addBlock</span><span class="p">(</span><span class="o">*</span><span class="nx">addBlockData</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">printChainCmd</span><span class="p">.</span><span class="nf">Parsed</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">cli</span><span class="p">.</span><span class="nf">printChain</span><span class="p">()</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>커맨드라인 인자를 파싱하기 위해 표준 패키지인 <a href="https://golang.org/pkg/flag/">flag</a>를 사용한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">addBlockCmd</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;addblock&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>
<span class="nx">printChainCmd</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;printchain&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>
<span class="nx">addBlockData</span> <span class="o">:=</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;data&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;Block data&#34;</span><span class="p">)</span>
</code></pre></div><p>우선, <strong>addBlock</strong>과 <strong>printchain</strong>이라는 두 개의 하위 커맨드를 만들고 <strong>addBlock</strong>에 <strong>-data</strong> 플래그를 추가한다. <strong>printchain</strong>에는 플래그가 없다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">switch</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;addblock&#34;</span><span class="p">:</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="k">case</span> <span class="s">&#34;printchain&#34;</span><span class="p">:</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">printChainCmd</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="k">default</span><span class="p">:</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nf">printUsage</span><span class="p">()</span>
        <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>다음엔 사용자가 입력한 커맨드를 검사하고 관련된 <strong>flag</strong> 하위커맨드를 파싱한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Parsed</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">*</span><span class="nx">addBlockData</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                <span class="nx">addBlockCmd</span><span class="p">.</span><span class="nf">Usage</span><span class="p">()</span>
                <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nf">addBlock</span><span class="p">(</span><span class="o">*</span><span class="nx">addBlockData</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">printChainCmd</span><span class="p">.</span><span class="nf">Parsed</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nf">printChain</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>다음으로 어떤 하위커맨드가 파싱되었는지 확인한 뒤 관련 함수를 실행한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cli</span> <span class="o">*</span><span class="nx">CLI</span><span class="p">)</span> <span class="nf">addBlock</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nx">bc</span><span class="p">.</span><span class="nf">AddBlock</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Success!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cli</span> <span class="o">*</span><span class="nx">CLI</span><span class="p">)</span> <span class="nf">printChain</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">bci</span> <span class="o">:=</span> <span class="nx">cli</span><span class="p">.</span><span class="nx">bc</span><span class="p">.</span><span class="nf">Iterator</span><span class="p">()</span>

        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">block</span> <span class="o">:=</span> <span class="nx">bci</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Prev. hash: %x\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">.</span><span class="nx">PrevBlockHash</span><span class="p">)</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Data: %s\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hash: %x\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>

                <span class="nx">pow</span> <span class="o">:=</span> <span class="nf">NewProofOfWork</span><span class="p">(</span><span class="nx">block</span><span class="p">)</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;PoW: %s\n&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatBool</span><span class="p">(</span><span class="nx">pow</span><span class="p">.</span><span class="nf">Validate</span><span class="p">()))</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">block</span><span class="p">.</span><span class="nx">PrevBlockHash</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">break</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>이 코드는 이전에 봤던 코드와 아주 유사하다. 유일한 차이점은 블록체인의 블록을 순회하기 위해 <strong>BlockchainIterator</strong>를 사용하고 있다는 것이다.</p>
<p>이에 맞게 <strong>main</strong> 함수를 수정하는 것도 잊지 말자.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">bc</span> <span class="o">:=</span> <span class="nf">NewBlockchain</span><span class="p">()</span>
        <span class="k">defer</span> <span class="nx">bc</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

        <span class="nx">cli</span> <span class="o">:=</span> <span class="nx">CLI</span><span class="p">{</span><span class="nx">bc</span><span class="p">}</span>
        <span class="nx">cli</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>커맨드라인 인자 입력과 무관하게 새로운 <strong>Blockchain</strong>이 만들어지고 있음을 볼 수 있다.</p>
<p>끝났다! 모든 기능이 잘 동작하는지 확인해보자.</p>
<pre><code>$ blockchain_go printchain
No existing blockchain found. Creating a new one...
Mining the block containing &quot;Genesis Block&quot;
000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true

$ blockchain_go addblock -data &quot;Send 1 BTC to Ivan&quot;
Mining the block containing &quot;Send 1 BTC to Ivan&quot;
000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13

Success!

$ blockchain_go addblock -data &quot;Pay 0.31337 BTC for a coffee&quot;
Mining the block containing &quot;Pay 0.31337 BTC for a coffee&quot;
000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148

Success!

$ blockchain_go printchain
Prev. hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
Data: Pay 0.31337 BTC for a coffee
Hash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148
PoW: true

Prev. hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
Data: Send 1 BTC to Ivan
Hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
PoW: true

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true
</code></pre><h1 id="결론">결론</h1>
<p>다음 파트에서는 주소, 지갑 그리고 트랜잭션을 구현해볼 것이다.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2fbuilding-blockchain-in-go-part-3%2f - %5bGo%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%5d%20Part%203%3a%20%ec%98%81%ec%86%8d%ec%84%b1%20%eb%b0%8f%20CLI by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
            <div class="adsense">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                
                <ins class="adsbygoogle"
                    style="display:block"
                    data-ad-client="ca-pub-9436560391944255"
                    data-ad-slot="5717491307"
                    data-ad-format="auto"
                    data-full-width-responsive="true"></ins>
                <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>
            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/go-modules-private-repo">Go 프라이빗 모듈 가져오기<aside class="dates">Apr 18 2020</aside></a>
        </li>
    
        <li>
            <a href="/debugging-containerized-go-app">컨테이너 내부 Go 애플리케이션 디버깅하기<aside class="dates">Feb 13 2020</aside></a>
        </li>
    
        <li>
            <a href="/debug-memory-leak-with-node-heapdump">푸시 데몬 메모리 누수 디버깅하기<aside class="dates">Nov 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/scheduling-cron-job-in-seconds-interval">Cron에서 초단위로 스케줄링하기<aside class="dates">Aug 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/dynamodb-batch-retry-with-exponential-backoff">DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)<aside class="dates">Jun 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/redis-migration">IDC에서 AWS로 Redis 데이터 이전하기<aside class="dates">Feb 1 2019</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-7">[Go로 구현하는 블록체인] Part 7: 네트워크<aside class="dates">Jun 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-84081627-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
