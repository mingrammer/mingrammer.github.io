<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">
		
		
		<meta property="og:title" content="파이썬 curses에서 스크롤 및 페이징 기능 구현하기" />
<meta property="og:description" content="TUI 애플리케이션을 개발하다보면 마주치는 어렵지는 않지만 다소 까다로운 문제가 하나 있는데, 바로 TUI 환경에서 화면을 동적으로 제어하는 것이다. 특히 한정된 화면에" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mingrammer.com/how-to-implement-the-scroll-and-paging-in-python-curses/" />
<meta property="article:published_time" content="2018-03-06T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-03-06T00:00:00&#43;00:00"/>

		

		<meta name="generator" content="Hugo 0.55.6" />
		<title>파이썬 curses에서 스크롤 및 페이징 기능 구현하기 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/custom.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        파이썬 curses에서 스크롤 및 페이징 기능 구현하기
                    </h1>
                    <h2 class="headline">
                    Mar 6, 2018 00:00
                    · 1911 words
                    · 4 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/curses">curses</a>
                          
                              <a href="https://mingrammer.com/tags/paging">paging</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#스크롤-scroll">스크롤 (Scroll)</a>
<ul>
<li><a href="#구현">구현</a></li>
<li><a href="#스크롤-데모">스크롤 데모</a></li>
</ul></li>
<li><a href="#페이징-paging">페이징 (Paging)</a>
<ul>
<li><a href="#구현-1">구현</a></li>
<li><a href="#페이징-데모">페이징 데모</a></li>
</ul></li>
<li><a href="#마무리">마무리</a></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<p>TUI 애플리케이션을 개발하다보면 마주치는 어렵지는 않지만 다소 까다로운 문제가 하나 있는데, 바로 TUI 환경에서 화면을 동적으로 제어하는 것이다. 특히 한정된 화면에서 <strong>리스트</strong>를 다루게 된다면 <strong>스크롤(Scroll)</strong> 기능은 필수이며 리스트가 아주 길어질 수 있는 경우라면 <strong>페이징(Paging)</strong> 기능 또한 거의 필수적이게 된다. 이 포스팅에서는 파이썬의 <strong>curses</strong>라는 라이브러리에서 이 두 기능을 구현하는 방법에 대해서 다룰 것이다.</p>

<p>그럼 바로 본론으로 들어가서, <strong>curses</strong>에서 스크롤과 페이징을 구현하는 방법에 대해서 알아보겠다. 참고로 이 포스팅은 curses 튜토리얼은 아니며, 따라서 curses를 이미 사용해봤던 사람들한테 더욱 유용할 것이다.</p>

<p>이 포스팅에서는 전체 소스코드가 아닌 스크롤 및 페이징의 구현부 소스코드만 살펴볼 것이며, 전체 소스코드 및 실행 방법은 <a href="https://github.com/mingrammer/python-curses-scroll-example">Python Curses Scroll Example</a>을 참고하면 된다. (전체 소스코드 : <a href="https://github.com/mingrammer/python-curses-scroll-example/blob/master/tui.py">tui.py</a>)</p>

<p><br></p>

<h1 id="스크롤-scroll">스크롤 (Scroll)</h1>

<p>스크롤 구현의 아이디어는 간단하다. 전체 리스트에서의 현재 보여지는 윈도우의 최상단 위치와 현재 커서 위치를 기준으로 다음 커서의 위치를 계산하여 커서를 이동시키는 것이다. 이해하기 쉽게 실제 구현부 코드를 살펴보자.</p>

<h2 id="구현">구현</h2>

<p>다음은 TUI 애플리케이션 실행 후 사용자로부터 키보드 입력을 받는 부분인데 <code>KEY_UP</code>과 <code>KEY_DOWN</code> 입력을 받게 되면 스크롤을 수행하는 <code>scroll</code> 메서드를 실행하게된다. (참고로, <code>UP=1</code>, <code>DOWN=-1</code>)</p>

<pre><code class="language-python">def input_stream(self):
    &quot;&quot;&quot;사용자 입력을 대기하며 입력값에 따라 해당되는 메서드를 실행함&quot;&quot;&quot;
    while True:
        self.display()

        ch = self.window.getch()
        if ch == curses.KEY_UP:
            self.scroll(self.UP)
        elif ch == curses.KEY_DOWN:
            self.scroll(self.DOWN)
        elif ch == curses.KEY_LEFT:
            self.paging(self.UP)
        elif ch == curses.KEY_RIGHT:
            self.paging(self.DOWN)
        elif ch == curses.ascii.ESC:
            break
</code></pre>

<p>스크롤을 구현할 때에는 다음 두 가지를 고려해야한다.</p>

<ul>
<li>현재 커서가 현재 윈도우의 최상단 혹은 최하단에 위치하면서 커서와 윈도우가 모두 움직이는 경우</li>
<li>현재 커서가 현재 윈도우의 중간에 위치해 커서만 움직이는 경우</li>
</ul>

<pre><code class="language-python"># top: 리스트에서의 현재 윈도우의 최상단 라인의 위치
# current: 현재 보여지는 윈도우 기준 현재 커서 위치
# max_lines: 한 번에 볼 수 있는 최대 항목의 갯수
# bottom: 커서가 위치할 수 있는 최하단 라인의 위치
#
# ┌--------------------------------------┐
# |1. Item                               |
# |--------------------------------------| &lt;- top = 1
# |2. Item                               |
# |3. Item                               |
# |4./Item///////////////////////////////| &lt;- current = 3
# |5. Item                               |
# |6. Item                               |
# |7. Item                               |
# |8. Item                               | &lt;- max_lines = 7
# |--------------------------------------|
# |9. Item                               |
# |10. Item                              | &lt;- bottom = 10
# |                                      |
# |                                      | &lt;- page = 1 (0 and 1)
# └--------------------------------------┘


def scroll(self, direction):
    # 방향에 따른 다음 라인 커서 위치 계산
    next_line = self.current + direction

    # 윈도우 스크롤 업
    # 현재 커서가 윈도우의 상단에 위치하나, 윈도우의 상단 라인이 최상단에 닿지 않았으므로 윈도우 스크롤 업이 가능하다
    if (direction == self.UP) and (self.top &gt; 0 and self.current == 0):
        self.top += direction
        return

    # 윈도우 스크롤 다운
    # 다음 커서가 현재 윈도우의 하단에 위치하나, 커서의 절대 위치가 아직 최하단까지 도달하진 않았으므로 윈도우 스크롤 다운이 가능하다
    if (direction == self.DOWN) and (next_line == self.max_lines) and (self.top + self.max_lines &lt; self.bottom):
        self.top += direction
        return

    # 스크롤 업
    # 현재 커서가 최상단보다 아래에 있으므로 스크롤 업이 가능하다
    if (direction == self.UP) and (self.top &gt; 0 or self.current &gt; 0):
        self.current = next_line
        return

    # 스크롤 다운
    # 다음 커서가 현재 윈도우의 하단보다 위에 있으며, 커서의 절대 위치가 아직 최하단까지 도달하진 않았으므로 스크롤 다운이 가능하다
    if (direction == self.DOWN) and (next_line &lt; self.max_lines) and (self.top + next_line &lt; self.bottom):
        self.current = next_line
</code></pre>

<h2 id="스크롤-데모">스크롤 데모</h2>

<ul>
<li>스크롤 업 : <strong>↑</strong></li>
<li>스크롤 다운 : <strong>↓</strong></li>
</ul>

<p><a href="https://asciinema.org/a/166994"><img src="https://asciinema.org/a/166994.png" alt="asciicast" /></a></p>

<p><br></p>

<h1 id="페이징-paging">페이징 (Paging)</h1>

<p>스크롤은 커서 위치를 조정하면서 동작하는 반면, 페이징은 윈도우의 상단 라인 (<code>top</code> 변수)의 위치를 조정하면서 동작한다. 그렇기 때문에 페이징을 구현할 때에는 한가지 유의 해야할 부분이 있는데, 페이징을 하다가 마지막 페이지에 도달했을 때 현재 커서가 마지막 페이지에 나타나는 항목의 리스트보다 아래에 위치하는 경우, 이 커서 위치를 재조정해줘야 한다는 것이다.</p>

<h2 id="구현-1">구현</h2>

<p>마찬가지로 키보드 입력을 받는 부분에서 <code>KEY_LEFT</code>와 <code>KEY_RIGHT</code> 입력을 받게 되면 페이징을 수행하는 <code>paging</code> 메서드를 실행하게된다.</p>

<pre><code class="language-python">def paging(self, direction):
    # 윈도우의 상단 위치값과 현재 커서 위치로 현재 페이지와 다음 페이지를 계산
    current_page = (self.top + self.current) // self.max_lines
    next_page = current_page + direction

    # 마지막 페이지에 도달 했을 때 현재 커서가 마지막 페이지에 나타나는 항목의 리스트보다 아래에 있는 경우,
    # 현재 커서를 마지막 페이지 리스트의 마지막 항목 위치로 조정
    if next_page == self.page:
        self.current = min(self.current, self.bottom % self.max_lines - 1)

    # 페이지 업
    # 현재 페이지가 첫 페이지가 아닌 경우, 페이지 업이 가능하다
    # 윈도우 상단의 위치는 음수가 될 수 없으므로, 음수가 될 경우 0으로 조정
    if (direction == self.UP) and (current_page &gt; 0):
        self.top = max(0, self.top - self.max_lines)
        return

    # 페이지 다운
    # 현재 페이지가 마지막 페이지가 아닌 경우, 페이지 다운이 가능하다
    if (direction == self.DOWN) and (current_page &lt; self.page):
        self.top += self.max_lines
        return
</code></pre>

<h2 id="페이징-데모">페이징 데모</h2>

<ul>
<li>페이지 업 : <strong>←</strong></li>
<li>페이지 다운 : <strong>→</strong></li>
</ul>

<p><a href="https://asciinema.org/a/166995"><img src="https://asciinema.org/a/166995.png" alt="asciicast" /></a></p>

<p><br></p>

<h1 id="마무리">마무리</h1>

<p>이제까지 <strong>curses</strong>를 사용해 TUI 환경에서 스크롤과 페이징을 구현하는 기법에 대해서 살펴보았다. 비단 curses가 아니더라도 다른 언어 및 라이브러리를 활용해 TUI 스크롤/페이징을 구현하고자 한다면 기본적인 아이디어는 그대로 차용할 수 있을 것이다. 다음엔 TUI 환경에서 나타날 수 있는 다른 다양한 동작들의 구현에 대해서 포스팅을 해보겠다.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2fhow-to-implement-the-scroll-and-paging-in-python-curses%2f - %ed%8c%8c%ec%9d%b4%ec%8d%ac%20curses%ec%97%90%ec%84%9c%20%ec%8a%a4%ed%81%ac%eb%a1%a4%20%eb%b0%8f%20%ed%8e%98%ec%9d%b4%ec%a7%95%20%ea%b8%b0%eb%8a%a5%20%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/dynamodb-batch-retry-with-exponential-backoff">DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)<aside class="dates">Jun 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/redis-migration">IDC에서 AWS로 Redis 데이터 이전하기<aside class="dates">Feb 1 2019</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-7">[Go로 구현하는 블록체인] Part 7: 네트워크<aside class="dates">Jun 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-3">[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI<aside class="dates">May 22 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-2">[Go로 구현하는 블록체인] Part 2: 작업 증명<aside class="dates">May 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-1">[Go로 구현하는 블록체인] Part 1: 기본 프로토타입<aside class="dates">May 17 2018</aside></a>
        </li>
    
        <li>
            <a href="/project-euler-maximum-path-sum">[프로젝트 오일러] 최대 경로합 문제 (18/67)<aside class="dates">May 1 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-84081627-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
