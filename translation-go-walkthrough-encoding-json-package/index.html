<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">
		
		

		<meta name="generator" content="Hugo 0.31.1" />
		<title>[번역] Go 둘러보기 - encoding/json 패키지 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [번역] Go 둘러보기 - encoding/json 패키지
                    </h1>
                    <h2 class="headline">
                    Dec 3, 2016 00:00
                    · 5916 words
                    · 12 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/go-walkthrough">go walkthrough</a>
                          
                              <a href="https://mingrammer.com/tags/encoding">encoding</a>
                          
                              <a href="https://mingrammer.com/tags/json">json</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#json이란-무엇인가">JSON이란 무엇인가?</a></li>
<li><a href="#json-사용의-트레이드-오프">JSON 사용의 트레이드 오프</a></li>
<li><a href="#언제-json을-사용해야-하는가">언제 JSON을 사용해야 하는가?</a></li>
<li><a href="#스트림-인코딩">스트림 인코딩</a>
<ul>
<li><a href="#타입-검사">타입 검사</a></li>
<li><a href="#인코더-컴파일">인코더 컴파일</a></li>
<li><a href="#필드별-옵션">필드별 옵션</a></li>
<li><a href="#재귀-처리">재귀 처리</a></li>
</ul></li>
<li><a href="#스트림-디코딩">스트림 디코딩</a>
<ul>
<li><a href="#json-스캐닝">JSON 스캐닝</a></li>
<li><a href="#버퍼-미리보기">버퍼 미리보기</a></li>
<li><a href="#토큰-디코딩">토큰 디코딩</a></li>
<li><a href="#커스텀-언마샬링-unmarshaling">커스텀 언마샬링(Unmarshaling)</a></li>
</ul></li>
<li><a href="#지연-처리">지연 처리</a></li>
<li><a href="#깔끔한-출력">깔끔한 출력</a></li>
<li><a href="#인코딩-디코딩시-에러-핸들링">인코딩/디코딩시 에러 핸들링</a></li>
<li><a href="#대체-구현">대체 구현</a></li>
<li><a href="#결론">결론</a></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<blockquote>
<p><a href="https://medium.com/go-walkthrough">Go Walkthrough</a> 시리즈의 <a href="https://medium.com/go-walkthrough/go-walkthrough-encoding-json-package-9681d1d37a8f#.eszbi1cjw">Go Walkthrough: encoding/json package</a>를 번역한 글입니다.</p>
</blockquote>

<p>좋든 나쁘든, JSON은 인터넷의 인코딩이다. 이것의 공식적인 정의는 냅킨 뒷면에 쓸 수 있을 정도로 간단하지만 이는 문자열, 숫자, 부울, 널(nulls), 맵(maps) 그리고 배열을 인코딩 할 수 있다. 이러한 간결함 덕에, 모든 언어는 JSON 파서를 가지고 있다.</p>

<p>Go에서의 구현체는 <a href="https://golang.org/pkg/encoding/json/">encoding/json</a>이라고 하는 패키지이며 이는 Go 객체에 대한 JSON 인코딩을 원활하게 추가할 수 있도록 해준다. 그러나, 광범위하게 리플렉션을 사용함으로써, <em>encoding/json</em> 은 가장 많이 사용되는 패키지중 하나임에도 불구하고 이해하기 어려운 패키지중 하나이다. 우리는 이 패키지가 어떻게 동작하는지에 대해 자세히 살펴볼 것이다. 패키지의 사용법뿐만 아니라 내부 함수들이 어떻게 동작하는지도 살펴볼 것이다.</p>

<p>이 포스트는 표준 라이브러리를 이해하는데 도움을 주기위한 Go 둘러보기 시리즈의 일부이다. 기존에 생성된 문서(자동으로 생성된 Go 문서)는 많은 정보를 제공하지만, 이는 패키지를 실제 상황에서 이해하기에는 어려울 수 있다. 이 시리즈는 일상적으로 사용되는 애플리케이션에서 표준 패키지들이 어떻게 사용되는지에 대한 컨텍스트를 제공할 수 있도록 도와준다. 질문이나 코멘트가 있다면 트위터에서 <a href="https://twitter.com/benbjohnson">@benbjohnson</a>로 찾아오면 된다.</p>

<p><br></p>

<h1 id="json이란-무엇인가">JSON이란 무엇인가?</h1>

<p>JSON은 <em>JavaScript Object Notation</em> 의 약자로 객체 리터럴을 정의하는 자바스크립트의 하위 집합이다. 자바스크립트는 정적 선언 타이핑이 없기 때문에 언어 리터럴은 암시적 타입을 가져야 한다. 문자열은 쌍 따옴표로 감싸고, 배열은 괄호로 감싸며, 맵은 중괄호로 감싼다.</p>

<pre><code class="language-javascript">{&quot;name&quot;: &quot;mary&quot;, &quot;friends&quot;:  [&quot;stu&quot;, &quot;becky&quot;], age: 30}
</code></pre>

<p>이 느슨한 타입 정보들은 자바스크립트 개발자들에겐 저주지만, 이는 데이터를 매우 쉽고 간결하게 표현하는 방법을 제공한다.</p>

<p><br></p>

<h1 id="json-사용의-트레이드-오프">JSON 사용의 트레이드 오프</h1>

<p>JSON은 사용하기는 쉽지만, 몇가지 문제가 발생할 수 있다. 사람이 쉽게 읽을 수 있는 포맷들은 일반적으로 컴퓨터가 파싱하기에는 느리다. 예를 들면, 내 맥북 프로에서 <em>encoding/json</em> 를 벤치마킹하면 인코딩과 디코딩 속도가 각각 100 MB/sec과 27 MB/sec가 나온다.</p>

<pre><code>$ go test -bench=. encoding/json
BenchmarkCodeEncoder-4      106.26 MB/s
BenchmarkCodeDecoder-4      27.76 MB/s
</code></pre>

<p>그러나 일반적으로 바이너리 디코더는 데이터를 몇 배 더 빠르게 파싱할 수 있다. 이 문제는 데이터를 읽는 방식 때문에 발생한다. &ldquo;123.45&rdquo;와 같은 JSON 숫자 리터럴은 두 가지 반복적인 단계로 디코딩 되어야한다.</p>

<ol>
<li>각 바이트를 읽어 숫자인지 닷(dot, .)인지를 검사한다. 만약 숫자가 아닌 데이터를 읽으면 숫자 리터럴 스캐닝을 멈춘다.</li>
<li>10진수 숫자 리터럴을 <em>int64</em> 나 IEEE-754 부동 소수점 숫자 표현식과 같은 2진수 포맷으로 변환한다.</li>
</ol>

<p>이는 들어오는 모든 바이트에 대한 많은 파싱들뿐만 아니라 디코더상의 미리보기 버퍼를 포함한다. 이와는 대조적으로, 바이너리 디코더는 단순히 얼마나 많은 바이트를 파싱해야 하는지(예를 들어 2,4, 또는 8)와 플립할 수 있는 엔디안만 알면된다. 이 바이너리 파싱 연산은 또한 <a href="https://en.wikipedia.org/wiki/Instruction_pipelining">CPU 파이프라이닝(pipelining)</a>을 늦추는 <a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29">분기(branching)</a>가 필요하지 않다.</p>

<p><br></p>

<h1 id="언제-json을-사용해야-하는가">언제 JSON을 사용해야 하는가?</h1>

<p>일반적으로 JSON은 손쉬운 데이터 교환이 가장 큰 목적이고 성능이 크게 중요하지 않을 경우 사용된다. JSON은 사람이 읽기 쉽기 때문에, 뭔가 잘못될 경우 디버깅 하기가 쉽다. 반면에, 바이너리 프로토콜은 분석되기 전에 우선 디코딩 되어야한다.</p>

<p>많은 애플리케이션에서 인코딩/디코딩 성능은 쉽게 수평 확장이 가능하기 때문에 낮은 우선순위를 가진다. 예를 들어, API 엔드포인트를 제공하기 위해 추가적인 서버를 증설하는건 쉽다. 왜냐하면 인코딩은 서로 다른 서버들간의 조정 등이 필요없기 때문이다. 그러나 데이터베이스는 서버를 추가해야할 때 스케일링 하기가 쉽지 않다.</p>

<p><br></p>

<h1 id="스트림-인코딩">스트림 인코딩</h1>

<p>json 패키지에는 값을 JSON으로 인코딩하는 두 가지 방법이 있다. 첫번째는 값을 io.<a href="https://golang.org/pkg/io/">Writer</a>로 인코딩하는 스트림 기반 json.<a href="https://golang.org/pkg/encoding/json/#Encoder">Encoder</a>이다:</p>

<pre><code class="language-go">type Encoder struct {}
func NewEncoder(w io.Writer) *Encoder
func (enc *Encoder) Encode(v interface{}) error
</code></pre>

<blockquote>
<p>io : <a href="https://golang.org/pkg/io/">io</a>, Writer : <a href="https://golang.org/pkg/io/">Writer</a>, Encode : <a href="https://golang.org/pkg/encoding/json/#Encoder">Encoder</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>두번째 옵션은 인코딩된 값을 인메모리 바이트 슬라이스로 반환하는 json.<a href="https://golang.org/pkg/encoding/json/#Marshal">Marshal</a>()이다:</p>

<pre><code class="language-go">func Marshal(v interface{}) ([]byte, error)
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error: <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>이 인코더들에 값을 전달하면, JSON 라이브러리는 타입 정의 검사, 인코더 컴파일 그리고 데이터값 재귀 처리의 복잡한 프로세스를 실행한다. 이제 각각에 대해 자세히 알아보자.</p>

<p><br></p>

<h2 id="타입-검사">타입 검사</h2>

<p>인코더에 값을 전달하면 가장 먼저 값의 타입 인코더를 검색한다. 타입들은 Go의 <a href="https://golang.org/pkg/reflect/">reflect</a> 패키지에 의해 검사되며 <a href="https://golang.org/pkg/encoding/json/">json</a> 패키지는 이 reflect.<a href="https://golang.org/pkg/reflect/#Type">Type</a> 값들에 대한 내부 매핑을 가지고 있다. <a href="https://golang.org/pkg/encoding/json/">json</a> 패키지에는 int, string, map, struct 그리고 slice와 같은 내장 타입들에 대한 하드코딩된 구현체들이 있다. 이들은 정말 단순하다 - <em>stringEncoder</em> 는 문자열값을 쌍 따옴표로 감싸며 필요한 경우 문자들을 이스케이프하고, <em>intEncoder</em> 는 정수를 문자열 포맷으로 변환하고, 등등.</p>

<p><br></p>

<h2 id="인코더-컴파일">인코더 컴파일</h2>

<p>내장 타입이 아닌 타입들에 대해선, 인코더가 즉시 생성되고 재사용을 위해 캐싱된다. 우선, 인코더는 해당 타입이 json.<a href="https://golang.org/pkg/encoding/json/#Marshaler">Marshaler</a>를 구현하고 있는지 확인한다:</p>

<pre><code class="language-go">type Marshaler interface {
        MarshalJSON() ([]byte, error)
}
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error: <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>만약 구현하고 있다면 마샬링은 타입에 따라 결정된다. 이는 타입중 하나가 <a href="https://golang.org/pkg/encoding/json/">json</a> 패키지의 리플렉션 기반 인코더로 처리할 수 없는 특별한 JSON 표현식을 가진 경우 매우 유용하다.</p>

<p>다음으로, 인코더는 타입이 encoding.<a href="https://golang.org/pkg/encoding/#TextMarshaler">TextMarshaler</a>을 구현하고 있는지 확인한다:</p>

<pre><code class="language-go">type TextMarshaler interface {
        MarshalText() (text []byte, err error)
}
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error: <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>만약 구현하고 있다면 이는 해당 함수로부터 값을 생성하고 결과값을 JSON 문자열로 인코딩 할 것이다. 이는 time.<a href="https://golang.org/pkg/time/#Time">Time</a>을 사용할 때 항상 볼 수 있다. 왜냐하면 time.<a href="https://golang.org/pkg/time/#Time">Time</a>은 <a href="https://golang.org/pkg/time/#Time.MarshalText">MarshalText</a>() 메서드를 가지고 있기 때문이며, JSON 인코더는 time.<a href="https://golang.org/pkg/time/#Time">Time</a> 값을 <a href="https://golang.org/pkg/time/#RFC3339">RFC 3339</a> 포맷 문자열로 인코딩 할 것이다.</p>

<p>마지막으로, 두 인터페이스 모두 구현되어 있지 않을 경우엔 기본 인코더를 기반으로 재귀적으로 인코더를 생성한다. 예를 들어, <em>int</em> 필드와 <em>string</em> 필드를 가지는 <em>struct</em> 로 이루어진 타입은 <em>intEncoder</em> 와 <em>stringEncoder</em> 를 갖는 <em>structEncoder</em> 를 생성할 것이다. 다시 말하지만, 인코더 생성은 딱 한 번만 이루어지며 만들어진 인코더는 차후의 사용을 위해 캐싱될 것이다.</p>

<p><br></p>

<h2 id="필드별-옵션">필드별 옵션</h2>

<p>구조체 인코더에 대한 한가지 중요한 점은 이는 인코딩을 위한 필드별 옵션을 결정하기 위해  필드 태그를 읽는다는 것이다. 태그는 구조체의 끝에서 가끔 볼 수 있는 역 따옴표(`)로 감싸진 문자열이다.</p>

<p>예시:</p>

<pre><code class="language-go">type User struct {
        Name    string `json:&quot;name&quot;`
        Age     int    `json:&quot;age,omitempty&quot;`
        Zipcode int    `json:&quot;zipcode,string&quot;`
}
</code></pre>

<p>이 옵션은 다음을 포함한다:</p>

<ul>
<li>필드 키 이름을 바꾼다. 많은 JSON 키는 카멜케이스이므로 이에 일치하도록 이름을 바꾸는것은 중요할 수 있다.</li>
<li><em>omitempty</em> 플래그는 빈 값을 갖는 비구조체 필드들을 하도록 설정할 수 있다.</li>
<li><em>string</em> 플래그는 필드가 문자열로 인코딩 되도록 강제하는데 사용될 수 있다. 예를 들면, 정수가 문자열로 인코딩 되도록 강제할 수 있다.</li>
</ul>

<p><br></p>

<h2 id="재귀-처리">재귀 처리</h2>

<p>마지막으로, 인코딩이 수행될 때 이는 <em>encodeState</em> 라고 하는 내장 버퍼에 기록된다. 이 객체는 값이 필요로하는 각 인코더로 전달되어 인코더가 바이트를 추가할 수 있도록 한다. json.<a href="https://golang.org/pkg/encoding/json/#Marshal">Marshal</a>이 호출되면, 이 버퍼의 바이트에 대한 참조가 반환된다.</p>

<p>json.<a href="https://golang.org/pkg/encoding/json/#Encoder">Encoder</a>를 사용할 때, <em>encodeState</em> 버퍼를 재사용하기 위해 내부적으로 sync.<a href="https://golang.org/pkg/sync/#Pool">Pool</a>가 사용된다. 이는 인코더가 필요로 하는 힙 메모리 할당 횟수를 최소화하므로 스트림 처리는 항상 json.<a href="https://golang.org/pkg/encoding/json/#Encoder">Encoder</a>를 사용한다.</p>

<p><br></p>

<h1 id="스트림-디코딩">스트림 디코딩</h1>

<p>JSON으로 인코딩된 바이트를 다시 객체로 변환하는 것은 인코딩 프로세스의 역과 비슷하지만 중요한 차이점이 있다.</p>

<p>바이트에서 JSON을 디코딩하는 방법은 두 가지가 있다. 첫번째는 io.<a href="https://golang.org/pkg/io/#Reader">Reader</a>로부터 디코딩 할 수 있는 스트림 기반 json.<a href="https://golang.org/pkg/io/#Reader">Decoder</a>이다:</p>

<pre><code class="language-go">type Decoder strcut {}
func NewDecoder(r io.Reader) *Decoder
func (dec *Decoder) Decode(v interface{}) error
</code></pre>

<blockquote>
<p>io : <a href="https://golang.org/pkg/io/">io</a>, Reader : <a href="https://golang.org/pkg/io/#Reader">Reader</a>, Decoder : <a href="https://golang.org/pkg/io/#Reader">Decoder</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>또는 json.[Unmarshal]() 함수를 사용해 바이트 슬라이스로부터 디코딩 할 수 있다:</p>

<pre><code class="language-go">func Unmarshal(data []byte, v interface{}) error
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>이 디코더들은 두 부분으로 동작한다. 우선 <em>scanner</em> 가 입력된 바이트를 토큰화하고 <em>decodeState</em> 가 토큰들을 Go 객체로 변환한다.</p>

<p><br></p>

<h2 id="json-스캐닝">JSON 스캐닝</h2>

<p><em>scanner</em> 는 JSON을 파싱하는데 쓰이는 내부 상태 머신(state machine)이다. 이는 여러 단계로 동작한다. 첫번째로, 이는 파싱을 위한 토큰의 타입을 결정하기 위해 값의 첫번째 바이트를 검사한다. 만약 그게 &ldquo;{&ldquo;라면 객체를 파싱해야하고, &ldquo;[&ldquo;라면 배열을 파싱해야한다. 이는 단순한 값에도 똑같이 적용된다. 쌍 따옴표는 문자열의 시작점을 나타내고, <em>&ldquo;t&rdquo;</em> 나 <em>&ldquo;f&rdquo;</em> 는 부울값의 시작을 나타내며, <em>0-9</em> 는 숫자의 시작을 나타낸다.</p>

<p>스캐닝 타입 결정이 끝나면, 이는 타입별 함수 (문자열 스캔, 숫자 스캔 등)로 전달된다. 맵이나 배열같은 복잡한 객체들에 대해선, 닫는 중괄호를 추적하는데 스택이 사용된다.</p>

<p><br></p>

<h2 id="버퍼-미리보기">버퍼 미리보기</h2>

<p>스캐닝의 흥미로운 부분은 버퍼 미리보기이다. JSON은 &ldquo;LL(1)으로 파싱가능&rdquo;하며 이는 스캐닝하는데 딱 하나의 바이트 버퍼만 필요하다는 의미이다. 이 버퍼는 다음 바이트를 미리 보는데 사용된다.</p>

<p>예를 들면, 숫자 스캐닝 함수는 숫자가 아닌 문자를 찾을 때까지 바이트를 계속 읽을 것이다. 그러나, 스트림으로부터 문자를 이미 읽었기 때문에 다른 스캐닝 함수가 사용할 수 있도록 이를 버퍼에서 빼줘야 한다. 이게 바로 버퍼 미리보기가 필요한 이유이다.</p>

<p><em>파서 작성에 관심이 있다면, 내가 Gopher Academy에 쓴 <a href="https://blog.gopheracademy.com/advent-2014/parsers-lexers/">Handwriting Parsers &amp; Lexers in Go</a>를 보라</em></p>

<p><br></p>

<h2 id="토큰-디코딩">토큰 디코딩</h2>

<p>토큰이 스캔되면 이제 해석해야한다. 이는 <em>decodeState</em> 의 일이다. 이 단계에서 디코딩될 입력값들은 처리될 각 토큰과 일치한다.</p>

<p>예를 들면, 만약 구조체 타입을 전달하면 디코더는 <em>&rdquo;{&rdquo;</em> 값을 기대할 것이다. 다른 토큰들이 들어오면 디코딩은 에러를 반환할 것이다. 토큰들을 값들과 일치시키는 이 단계는 <a href="https://golang.org/pkg/reflect/">reflect</a> 패키지를 많이 사용하지만 디코더는 이를 캐싱하지 않으므로 매 디코딩마다 리플렉션이 이루어진다.</p>

<p>여러분은 또한 Decoder.<a href="https://golang.org/pkg/encoding/json/#Decoder.Token">Token</a>()과 Decoder.<a href="https://golang.org/pkg/encoding/json/#Decoder.More">More</a>() 메서드를 사용해 토큰들을 스트림으로 처리할 수도 있다. 나는 이 메서드들을 사용해본 적은 없지만, 이런것들을 사용할 수 있다는걸 알아두면 좋다.</p>

<p><br></p>

<h2 id="커스텀-언마샬링-unmarshaling">커스텀 언마샬링(Unmarshaling)</h2>

<p>인코딩과 마찬가지로, 디코딩 커스텀 구현체도 만들 수 있다. 디코더는 먼저 타입이 json.<a href="https://golang.org/pkg/encoding/json/#Unmarshaler">Unmarshaler</a> 를 구현하고 있는지를 검사한다:</p>

<pre><code class="language-go">type Unmarshaler interface {
        UnmarshalJSON([]byte) error
}
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>이는 타입이 한 타입에 대한 JSON 값 전체를 받도록하며 타입 자체를 파싱할 수 있다. 이는 자체적으로 최적화 구현체를 구현하고싶을때 유용하다.</p>

<p>다음으로 디코더는 타입이 encoding.<a href="https://golang.org/pkg/encoding/#TextUnmarshaler">TextUnmarshaler</a>를 구현하고 있는지를 검사한다:</p>

<pre><code class="language-go">type TextUnmarshaler interface {
        UnmarshalText(text []byte) error
}
</code></pre>

<blockquote>
<p>byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>이는 사용하고 싶은 타입의 문자열 표현을 가지고 있을때 유용하다. 이의 한 예시는 내부적으로 정수로 표현되는 enum 타입을 문자열로써 인코딩/디코딩하는 경우이다.</p>

<p><br></p>

<h1 id="지연-처리">지연 처리</h1>

<p>json.<a href="https://golang.org/pkg/encoding/json/#Unmarshaler">Unmarshaler</a>의 대체제는 json.[RawMessage] 타입이다. <a href="https://golang.org/pkg/encoding/json/#RawMessage">RawMessage</a>를 사용하면, 원본 JSON 표현이 언마샬링이 완료된 후에 처리할 수 있는 필드에 저장된다. 이는 JSON 객체의 &ldquo;type&rdquo; 필드를 해석하고 값을 기반으로 JSON 파싱을 변경해야 할 때 유용하다.</p>

<pre><code class="language-go">type T struct {
        Type  string          `json:&quot;type&quot;`
        Value json.RawMessage `json:&quot;value&quot;`
}

func (t *T) Val() (interface{}, error) {
        switch t.Type {
        case &quot;foo&quot;:
                // &quot;t.Value&quot;를 Foo로 파싱
        case &quot;bar&quot;:
                // &quot;t.Value&quot;를 Bar로 파싱
        default:
                return nil, errors.New(&quot;invalid type&quot;)
        }
}
</code></pre>

<p>나는 개인적으로 추후 해석을 위해 JSON을 저장해두는것을 좋아하지 않기 때문에 json.<a href="https://golang.org/pkg/encoding/json/#Unmarshaler">Unmarshaler</a>가 좀 더 유용하다고 생각한다.</p>

<p>또 다른 지연 처리 방법은 JSON 숫자를 사용하는것이다. 왜냐하면 JSON은 정수와 실수를 구분하지 못하기 때문에 디코더는 <em>interface{}</em> 필드로 숫자를 디코딩 할 시  <em>float64</em> 로 변환한다. 파싱을 지연 시키기위해 json.<a href="https://golang.org/pkg/encoding/json/#Number">Number</a> 타입을 대신 사용할 수 있다.</p>

<pre><code class="language-go">type T struct {
        Value json.Number
}

...

if strings.Contains(t.Value, &quot;.&quot;) {
        v, err := t.Value.Float64()
        // 실수로 처리
} else {
        v, err := t.Value.Int64()
        // 정수로 처리
}
</code></pre>

<p>나는 디코딩시 주로 정적 타입을 사용하기 때문에 json.<a href="https://golang.org/pkg/encoding/json/#Number">Number</a>를 잘 사용하지 않는다.</p>

<p><br></p>

<h1 id="깔끔한-출력">깔끔한 출력</h1>

<p>JSON은 일반적으로 추가 공백 없이 하나의 긴 바이트로 쓰이지만, 이는 읽기가 어렵다. 여러분은 두 가지 방법으로 들여쓰기를 설정할 수 있다. JSON으로 인코딩된 인메모리 바이트 슬라이스의 경우엔 이를 json.[Indent]()() 함수에 전달할 수 있다:</p>

<pre><code class="language-go">func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
</code></pre>

<blockquote>
<p>bytes : <a href="https://golang.org/pkg/bytes/">bytes</a>, Buffer : <a href="https://golang.org/pkg/bytes/#Buffer">Buffer</a>, byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, string : <a href="https://golang.org/pkg/builtin/#string">string</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p><em>prefix</em> 인자는 모든 라인에 쓸 문자를 지정하고 <em>inednt</em> 는 들여쓰기에 사용는 문자를 지정한다. 나는 <em>prefix</em> 는 많이 사용하지 않지만 <em>indent</em> 값으로는 보통 2-스페이스  또는 탭을 사용한다.</p>

<p>json.<a href="https://golang.org/pkg/encoding/json/#Marshal">Marshal</a>()를 호출한 다음 json.<a href="https://golang.org/pkg/encoding/json/#Indent">Indent</a>를 호출해주는 json.<a href="https://golang.org/pkg/encoding/json/#MarshalIndent">MarshalIndent</a>()라는 헬퍼 함수가 있다.</p>

<p>만약 스트림 기반의 json.<a href="https://golang.org/pkg/encoding/json/#Encoder.SetIndent">Encoder</a>를 사용하고 있다면 <a href="https://golang.org/pkg/encoding/json/#Encoder.SetIndent">SetIndent</a>() 메서드를 사용해 들여쓰기를 할 수 있다:</p>

<pre><code class="language-go">func (enc *Encoder) SetIndent(prefix, indent string)
</code></pre>

<blockquote>
<p>Encoder : <a href="https://golang.org/pkg/encoding/json/#Encoder.SetIndent">Encoder</a>, string : <a href="https://golang.org/pkg/builtin/#string">string</a></p>
</blockquote>

<p>많은 사람들이 <a href="https://golang.org/pkg/encoding/json/#Encoder.SetIndent">SetIndent</a>()에 대해 모르고 바이트 슬라이스를 마샬링하고 들여쓴 후 그 결과를 스트림에 쓴다.</p>

<p>들여쓰기 함수의 반대는 <a href="https://golang.org/pkg/encoding/json/#Compact">Compact</a>() 함수이다:</p>

<pre><code class="language-go">func Compact(dst *bytes.Buffer, src []byte) error
</code></pre>

<blockquote>
<p>bytes : <a href="https://golang.org/pkg/bytes/">bytes</a>, Buffer : <a href="https://golang.org/pkg/bytes/#Buffer">Buffer</a>, byte : <a href="https://golang.org/pkg/builtin/#byte">byte</a>, error : <a href="https://golang.org/pkg/builtin/#error">error</a></p>
</blockquote>

<p>이는 <em>src</em> 를 대상 버퍼로 재작성하지만 모든 공백을 지운다.</p>

<p><br></p>

<h1 id="인코딩-디코딩시-에러-핸들링">인코딩/디코딩시 에러 핸들링</h1>

<p>json 패키지는 상당수의 에러 타입을 가지고 있다. 아래에 인코딩 또는 디코딩시 마주할 수 있는 에러 리스트가 있다:</p>

<ul>
<li>디코딩을 하기 위해 포인터가 아닌 값을 전달하여 실제로는 값의 복사본을 전달하게되면 디코더는 원래값에 디코딩을 할 수 없다. 디코더는 이를 잡아내고 <a href="https://golang.org/pkg/encoding/json/#InvalidUnmarshalError">InvalidUnmarshalError</a>를 반환한다.</li>
<li>만약 데이터가 잘못된 JSON 값을 포함하고 있으면 잘못된 문자의 바이트 위치와 함께 <a href="https://golang.org/pkg/encoding/json/#SyntaxError">SyntaxError</a>가 반환된다.</li>
<li>만약 에러가 json.<a href="https://golang.org/pkg/encoding/json/#Marshaler">Marshaler</a>나 encoding.<a href="https://golang.org/pkg/encoding/#TextMarshaler">TextMarshaler</a>에 의해 반환되면 이는 <a href="https://golang.org/pkg/encoding/json/#MarshalerError">MarshalerError</a>로 래핑된다.</li>
<li>만약 토큰이 대응하는 값으로 언마샬링 될 수 없는 경우 <a href="https://golang.org/pkg/encoding/json/#UnmarshalTypeError">UnmarshalTypeError</a>가 반환된다.</li>
<li><em>Infinity</em> 와 <em>NaN</em> 의 실수값은 JSON으로 표현할 수 없으며 <a href="https://golang.org/pkg/encoding/json/#UnsupportedValueError">UnsupportedValueError</a>가 반환된다.</li>
<li>JSON으로 표현할 수 없는 타입들(예를 들어, 함수, 복소수, 포인터 등등)의 경우 <a href="https://golang.org/pkg/encoding/json/#UnsupportedTypeError">UnsupportedTypeError</a>가 반환된다.</li>
<li>Go 1.2 이전에서 잘못된 UTF-8 문자는 [InvalidUTF8Error]()에러를 반환한다. 이후 버전은 단순히 잘못된 문자를 &ldquo;알 수 없는 문자&rdquo;를 의미하는 유니코드 문자인 <a href="http://unicode.org/cldr/utility/character.jsp?a=FFFD">U+FFFD</a>로 변환한다.</li>
</ul>

<p>에러가 많은 것처럼 보일 수 있지만, 에러를 로깅하고 사람이 직접 개입해서 조작하는것 이외에 코드에서 처리할 수 있는것은 많지 않다. 또한, 이들중 대부분은 유닛 테스트 커버리지가 있다면 개발 도중 잡아낼 수 있다.</p>

<p><br></p>

<h1 id="대체-구현">대체 구현</h1>

<p>몇 년 전 나는 리플렉션을 완전히 피하기 위해 컴파일 시 특정 타입별 인코더와 디코더를 생성해주는 <a href="https://github.com/benbjohnson/megajson">megajson</a>라는 툴을 개발했었다. 이는 인코딩과 디코딩을 훨씬 빠르게 만들어주었다. 그러나, 이 툴은 개념 증명이었으며 지원의 한계가 있어 결국 버려졌다.</p>

<p>운좋게도, <a href="http://paul.querna.org/">Paul Querna</a>이 동일한 일을 하지만 훨씬 나은 <a href="https://github.com/pquerna/ffjson">ffjson</a>이라는 구현체를 만들었다. JSON 인코딩과 디코딩 성능을 향상시키고자 한다면 이 툴을 강력히 추천한다.</p>

<p><br></p>

<h1 id="결론">결론</h1>

<p>JSON은 빠르게 실행해야하거나 유저에게 간단한 API를 제공해야 할 때 훌륭한 데이터 포맷이 될 수 있다. Go의 구현체는 리플렉션을 사용하여 간단하게 사용할 수 있는 많은 기능들을 제공한다.</p>

<p>우리는 JSON 표현을 포맷팅 하는 방법 뿐만 아니라 JSON의 인코딩과 디코딩 측면의 내부를 살펴보았다. 이 툴들은 밖에선 간단해 보일 수 있지만 내부적으로는 최대한 빠르고 효율적으로 만들기 위해 많은 일들이 일어나고 있다.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2ftranslation-go-walkthrough-encoding-json-package%2f - %5b%eb%b2%88%ec%97%ad%5d%20Go%20%eb%91%98%eb%9f%ac%eb%b3%b4%ea%b8%b0%20-%20encoding%2fjson%20%ed%8c%a8%ed%82%a4%ec%a7%80 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/cgo-cross-compile-for-mac-for-linux">맥에서 리눅스로 CGO 라이브러리 크로스 컴파일하기<aside class="dates">Dec 11 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-cpython-internals-arbitrary-precision-integer-implementation">[번역] 파이썬 내부 동작 원리: 임의 정밀도의 정수 구현<aside class="dates">Oct 10 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-10-common-software-architectural-patterns-in-a-nutshell">[번역] 10가지 소프트웨어 아키텍처 패턴 요약<aside class="dates">Sep 10 2017</aside></a>
        </li>
    
        <li>
            <a href="/setup-the-python-development-environment-with-pycharm-and-docker">PyCharm &#43; Docker로 파이썬 개발환경 셋업하기 (Dockerization)<aside class="dates">Jul 14 2017</aside></a>
        </li>
    
        <li>
            <a href="/introduce-comprehension-of-python">파이썬의 Comprehension 소개<aside class="dates">Jun 14 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-the-truth-is-in-the-code">[번역] 진실은 코드에 있다<aside class="dates">May 7 2017</aside></a>
        </li>
    
        <li>
            <a href="/tips-of-using-comma-in-python">파이썬의 Comma(,) 사용팁<aside class="dates">Apr 26 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-the-mathematics-of-machine-learning">[번역] 머신러닝 속 수학<aside class="dates">Apr 24 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-13-simple-rules-for-good-coding">[번역] 좋은 코딩을 위한 13 가지 간단한 규칙<aside class="dates">Apr 2 2017</aside></a>
        </li>
    
        <li>
            <a href="/understanding-the-asterisk-of-python">파이썬의 Asterisk(*) 이해하기<aside class="dates">Mar 20 2017</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-84081627-1', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
