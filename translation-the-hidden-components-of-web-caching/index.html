<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">
		
		

		<meta name="generator" content="Hugo 0.39" />
		<title>[번역] 웹 캐싱의 숨겨진 요소들 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [번역] 웹 캐싱의 숨겨진 요소들
                    </h1>
                    <h2 class="headline">
                    Apr 7, 2018 00:00
                    · 3452 words
                    · 7 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/caching">caching</a>
                          
                              <a href="https://mingrammer.com/tags/system">system</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#cpu-캐시">CPU 캐시</a></li>
<li><a href="#디스크">디스크</a></li>
<li><a href="#램-ram">램 (RAM)</a></li>
<li><a href="#간단한-웹서버">간단한 웹서버</a></li>
<li><a href="#데이터베이스-캐싱">데이터베이스 캐싱</a></li>
<li><a href="#응답-캐싱">응답 캐싱</a></li>
<li><a href="#함수-메모이제이션-memoization">함수 메모이제이션 (Memoization)</a></li>
<li><a href="#http-헤더를-통한-브라우저-캐싱">HTTP 헤더를 통한 브라우저 캐싱</a></li>
<li><a href="#프록시-서버">프록시 서버</a>
<ul>
<li><a href="#게이트-웨이">게이트 웨이</a></li>
<li><a href="#포워드-프록시">포워드 프록시</a></li>
<li><a href="#웹-가속기">웹 가속기</a></li>
<li><a href="#리버스-프록시">리버스 프록시</a></li>
<li><a href="#엣지-캐싱">엣지 캐싱</a></li>
</ul></li>
<li><a href="#마무리">마무리</a></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<blockquote>
<p><a href="https://medium.freecodecamp.org/the-hidden-components-of-web-caching-970854fe2c49">The hidden components of Web Caching</a>을 번역한 글입니다.</p>
</blockquote>

<p>캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.</p>

<p>캐싱은 웹 브라우저부터 웹서버와 하드디스크 및 CPU에 이르기까지 모든 곳에 적용된다. 그럼 이제 하위 레이어부터 상위 레이어까지의 순서대로 다양한 캐싱 레이어에 대해서 알아보자. 이 포스팅은 캐싱의 동작 <strong>방식</strong>보단 데이터가 캐싱되는 <strong>위치</strong>에 초점을 두고있다.</p>

<p><br></p>

<h1 id="cpu-캐시">CPU 캐시</h1>

<p>캐시 메모리는 RAM과 CPU 사이의 버퍼 역할을 하는 매우 빠른 메모리 타입이다. 이는 필요시 CPU가 즉시 사용할 수 있도록 자주 요청되는 데이터와 명령어들을 저장한다.</p>

<p>CPU는 적은 양의 고속 스토리지로 구성된 <strong>레지스터(Register)</strong>라고 하는 특수한 온칩 메모리(On-chip memory)를 내장하고있다. 레지스터는 가장 가깝고, 가장 작으며  가장 빠른 메모리이다. 때때로 이 레지스터를 <strong>L0 캐시</strong>라고 부르기도 한다.</p>

<p>또한 CPU는 <strong>L1 캐시</strong> (레벨 1)에서 <strong>L4 캐시</strong> (레벨 4)까지 최대 4개의 캐시 레벨에 엑세스할 수 있다. CPU 및 마더보드의 아키텍처는 레지스터가 L0 캐시인지 L1 캐시인지를 결정하며, 또한 여러 캐시 레이어가 CPU와 마더보드중 어디에 위치하는지도 결정한다.</p>

<p><img src="../images/2018-04-07-cache-memory-structure.png" alt="Cache Memory Structure" /></p>

<p><center>캐시 메모리 구조</center></p>

<p><br></p>

<h1 id="디스크">디스크</h1>

<p>HDD는 RAM에 비해 느리지만, SSD로 인해 점점 빨라지고 있다.</p>

<p>컴퓨터 스토리지에서, 디스크 버퍼 또는 캐시 버퍼라고도 불리는 디스크 캐시는 CPU와 물리적인 하드 디스크 사이의 버퍼 역할을 하는 HDD에 내장된 메모리이다.</p>

<p><img src="../images/2018-04-07-disk-cache.png" alt="Disk Cache" /></p>

<p>디스크 캐시는 디스크에 내용을 읽거나 쓸 때, 그 데이터를 곧 다시 읽게된다는 것을 전제로 한다.</p>

<p><br></p>

<h1 id="램-ram">램 (RAM)</h1>

<p>임시 데이터를 RAM과 HDD에 저장하는 것의 차이점은 성능, 비용 및 CPU 근접성이다.</p>

<p>램은 응답 시간이 수십 나노초인 반면에 HDD는 수십 밀리초의 응답 시간을 갖는다. 무려 여섯 자릿수나 차이 난다!</p>

<p><img src="../images/2018-04-07-msec-vs-nsec.png" alt="Millisecond vs Nanosecond" /></p>

<p>캐싱이 어떻게 동작하는지 더 깊이 이해하면 매우 효율적이고 비용이 저렴하며 유지 보수가 쉬운 애플리케이션을 설계할 수 있다.</p>

<p><br></p>

<h1 id="간단한-웹서버">간단한 웹서버</h1>

<p>웹에 요청을 날리면, 요청은 웹 브라우저로부터 하드 디스크의 파일 시스템에 있는 정적 리소스를 제공하는 웹 서버로 전달된다.</p>

<p><img src="../images/2018-04-07-simple-web-server.png" alt="Simple Web Server" /></p>

<p>웹 사이트 요청시 정적 파일을 제공한다고 가정해보자. 일반적인 워크플로우에서 인입 요청은 웹 서버에 의해 처리된다. 웹 서버는 하드 디스크로부터 파일을 가져와 파일의 내용을 반환하며 응답한다.</p>

<p>첫 번째 요청에서, 하드 디스크는 캐시를 확인하여 &ldquo;캐시 미스(Cache miss)&ldquo;를 발생시킨다. 그리고 하드 드라이브로부터 데이터를 가져와 추후에 다시 요청 받을 수 있음을 가정하고 캐시에 저장한다.</p>

<p>이후 요청부터는 캐시 조회시 &ldquo;캐시 히트(Cache hit)&ldquo;를 발생시킨다. 이 데이터는 덮어씌워져서 캐시 미스를 일으키기 전까지 버퍼에서 제공된다.</p>

<p><br></p>

<h1 id="데이터베이스-캐싱">데이터베이스 캐싱</h1>

<p>데이터베이스 쿼리는 데이터베이스 서버에서 수행되기 때문에 속도가 느려지고 부하가 몰릴 수도 있다. 이러한 쿼리들이 반복되면 결과값을 데이터베이스에 캐싱함으로써 응답 시간을 향상 시킬 수 있다. 이는 다수의 머신이 동일한 데이터베이스에 동일한 쿼리를 사용하는 경우에 더욱 유용하다.</p>

<p><img src="../images/2018-04-07-simple-web-server-with-a-database.png" alt="Simple Web Server with a Database" /></p>

<p>대다수의 데이터베이스 서버는 최적화된 캐싱을 위한 기능을 기본적으로 지원하나, 여러분의 애플리케이션의 요구사항에 맞게 수정할 수 있는 많은 파라미터들이 존재한다.</p>

<p><br></p>

<h1 id="응답-캐싱">응답 캐싱</h1>

<p>웹 서버는 응답을 캐싱하도록 구성할 수 있어 유사한 요청이 애플리케이션 호스트로 전달되지 않도록 할 수 있다. 이와 유사하게, 애플리케이션 호스트는 비용이 높은 데이터베이스 쿼리나 자주 요청되는 파일들에 대한 응답의 일부를 캐시할 수 있다.</p>

<p><img src="../images/2018-04-07-response-caching.png" alt="Response Caching" /></p>

<p>웹 서버의 응답은 메모리에 캐싱된다. 애플리케이션 캐시는 로컬 인메모리에 저장되거나 캐시 서버 위에서 실행되는 레디스와 같은 인메모리 데이터베이스에 저장할 수 있다.</p>

<blockquote>
<p><em>웹 서버와 애플리케이션 호스트는 애플리케이션 아키텍처에 따라 동일한 서비스 또는 서로 다른 서비스에 존재할 수 있다</em></p>
</blockquote>

<p><br></p>

<h1 id="함수-메모이제이션-memoization">함수 메모이제이션 (Memoization)</h1>

<p>메모이제이션은 비용이 높은 함수 호출을 최적화하여 특정 입력에 대해 해당 함수를 한 번만 실행되도록하는 캐싱의 한 형태이다. 이는 함수의 입력 파라미터에 해당하는 키와 결과값에 해당하는 값을 매칭시켜둔 조회 테이블을 통해 구현할 수 있다.</p>

<p><img src="../images/2018-04-07-function-memoization.png" alt="Function Memoization" /></p>

<p>메모이제이션은 프로그램의 성능을 높이는데 사용되는 일반적인 기술이다. 그러나 이는 드물게 요청되는 함수나 빠른 응답 속도를 가진 함수에 대해서는 적합하지 않을 수도 있다.</p>

<p><br></p>

<h1 id="http-헤더를-통한-브라우저-캐싱">HTTP 헤더를 통한 브라우저 캐싱</h1>

<p>모든 브라우저는 HTML 페이지, 자바스크립트 파일 및 이미지와 같은 웹 문서의 임시 저장을 위해 HTTP 캐시 (웹 캐시)의 구현을 제공하고있다.</p>

<p>이는 서버 응답이 올바른 HTTP 헤더 지시자를 제공하여 브라우저가 응답을 캐싱할 수 있는 시기와 지속 기간을 지시할 때 사용된다.</p>

<p>이는 아주 강력한 기능이며 다음과 같은 이점을 지녔다:</p>

<ul>
<li>리소스가 로컬 캐시로부터 빠르게 로드되기 때문에 사용자 경험이 향상된다. 요청이 네트워크를 통해 전송되지 않기 때문에 왕복 시간(RTT, Round Trip Time)이 발생하지 않는다</li>
<li>애플리케이션 서버 및 파이프라인의 다른 구성 요소에 대한 부하가 줄어든다</li>
<li>불필요한 대역폭에 대한 지불 비용이 줄어든다</li>
</ul>

<p><img src="../images/2018-04-07-browser-caching.png" alt="Browser Caching" /></p>

<p><br></p>

<h1 id="프록시-서버">프록시 서버</h1>

<p>컴퓨터 네트워크에서 프록시 서버는 컴퓨터 시스템, 하드웨어 어플라이언스 또는 애플리케이션 형태로 나타난다. 이는 다른 서버의 리소스를 찾는 클라이언트의 요청에 대한 중개 역할을 하며 그 반대의 경우도 마찬가지이다.</p>

<p>다양한 형태의 프록시 서버가 존재한다. 사용자의 로컬 컴퓨터, 네트워크 라우터 또는 클라이언트와 대상 호스트 사이의 다양한 중개 서버에 상주할 수 있다. 모든 프록시 서버는 캐싱이 가능하다.</p>

<p>일반적인 타입의 프록시 서버들을 살펴보자.</p>

<h2 id="게이트-웨이">게이트 웨이</h2>

<p>나가는 요청 또는 들어오는 응답을 변형없이 단순히 포워딩해주는 프록시 서버로 <strong>게이트웨이</strong>, <strong>터널링 프록시</strong>, <strong>웹 프록시</strong>, <strong>프록시</strong> 또는 <strong>애플리케이션 수준 프록시</strong>라고도 한다. 이러한 프록시는 일반적으로 방화벽 내부의 모든 클라이언트가 공유하므로 요청 캐싱에 적합한 후보가 된다.</p>

<h2 id="포워드-프록시">포워드 프록시</h2>

<p>포워드 프록시 (프록시 서버)는 일반적으로 클라이언트측 인프라에 설치된다. 포워드 프록시를 사용하도록 설정된 웹 브라우저는 나가는 요청을 프록시로 전달한다. 다음은 전달된 요청을 인터넷을 통해 대상 서버로 포워딩한다. 포워드 프록시의 장점중 하나는 클라이언트의 식별 아이디를 숨긴다는 것이다. (그러나 VPN이 익명성에 더 안전하다)</p>

<h2 id="웹-가속기">웹 가속기</h2>

<p>웹 가속기는 웹 사이트의 엑세스 시간을 줄여주는 프록시 서버이다. 이는 가까운 미래에 엑세스할 가능성이 있는 문서를 미리 페치한다. 이는 또한 문서 압축, 암호화 속도 향상, 이미지 품질을 낮추는 작업등을 수행할 수 있다.</p>

<h2 id="리버스-프록시">리버스 프록시</h2>

<p>리버스 프록시는 일반적으로 사설 네트워크의 서버에 직접 엑세스하지 못하도록하는 내부 프록시이다. 이는 내부 서버들간의 요청을 로드 밸런싱하거나 SSL 인증을 제공하거나 요청을 캐싱하는데 사용된다. 서버측 호스트는 캐시를 하고 많은 수의 요청을 관리하도록 도울 수 있다.</p>

<h2 id="엣지-캐싱">엣지 캐싱</h2>

<p>한편, 엣지 캐싱 (콘텐츠 전송 네트워크 (CDN))은 콘텐츠를 최종 사용자에게 더 가까이 저장하기 위해 캐싱 서버를 사용하는 것을 의미한다. 예를 들어, 인기있는 웹사이트를 방문하여 캐싱될 정적 콘텐츠를 다운로드하는 경우가 있다. 각 후속 사용자들은 캐시가 만료될 때까지 캐싱 서버로부터 직접 콘텐츠를 제공받는다.</p>

<p><br></p>

<p>원본 서버는 콘텐츠의 실제 원본이며 CDN에서 사용할 수있는 모든 콘텐츠를 제공할 수 있다.</p>

<p><img src="../images/2018-04-07-proxy-servers-in-the-request-pipeline.png" alt="Proxy Servers in the Request Pipeline" /></p>

<h1 id="마무리">마무리</h1>

<p>캐싱은 하드웨어와 소프트웨어부터 네트워킹 장비와 서비스에까지 이르는 파이프라인의 모든 단계에서 발생한다. 이는 본래 서버의 전체적인 성능 향상에 있어 중요한 역할을 한다. 모든 머신은 HDD와 CPU에서 유사한 캐싱 메커니즘을 가지고 있다.</p>

<p>캐시는 레이턴시와 네트워크 트래픽을 줄여 리소스를 표시하는데 필요한 시간을 단축시킨다. 모든 웹 애플리케이션은 CPU 연산과 관련된 응답 지연이 있다. 예를 들어 디스크 조회, 네트워크 레이턴시, 요청 큐잉, 네트워크 쓰로틀링등이 있다. 파이프라인에 있는 다양한 시스템에 걸쳐 이러한 여러 조합을 감안하면 왕복 시간은 빠르게 늘어날 것이다.</p>

<p>마지막으로, 다음은 캐싱으로부터 얻을 수 있는 몇 가지 이점들이다:</p>

<ul>
<li>레이턴시가 단축되어 응답 시간이 단축된다.</li>
<li>웹 트래픽이 줄어들어 왕복 시간(RTT)이 향상된다.</li>
<li>더 높은 처리량으로 본래 서버가 더 많은 요청을 처리 할 수 있다.</li>
<li>대역폭 소모가 줄어들어 네트워크 트래픽과 네트워크 정체가 줄어든다. 즉, 캐시되지 않은 실제 콘텐츠는 훨씬 빠르게 검색됨을 의미한다.</li>
<li>가까운 프록시 캐시에서 문서를 검색하면 전송 지연이 최소화된다.</li>
<li>인터넷상의 다양한 캐시가 데이터를 처리함으로써 본래 웹 서버의 작업 부하가 줄어든다.</li>
<li>크래시나 네트워크 문제로 인해 원격 서버를 사용할 수 없는 경우, 프록시를 통해 리소스의 캐시된 사본을 가져올 수 있다.</li>
</ul>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2ftranslation-the-hidden-components-of-web-caching%2f - %5b%eb%b2%88%ec%97%ad%5d%20%ec%9b%b9%20%ec%ba%90%ec%8b%b1%ec%9d%98%20%ec%88%a8%ea%b2%a8%ec%a7%84%20%ec%9a%94%ec%86%8c%eb%93%a4 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/building-blockchain-in-go-part-3">[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI<aside class="dates">May 22 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-2">[Go로 구현하는 블록체인] Part 2: 작업 증명<aside class="dates">May 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-1">[Go로 구현하는 블록체인] Part 1: 기본 프로토타입<aside class="dates">May 17 2018</aside></a>
        </li>
    
        <li>
            <a href="/project-euler-maximum-path-sum">[프로젝트 오일러] 최대 경로합 문제 (18/67)<aside class="dates">May 1 2018</aside></a>
        </li>
    
        <li>
            <a href="/writing-unit-test-for-time-dependent-code">시간에 의존하는 코드를 위한 테스트 작성하기<aside class="dates">Apr 29 2018</aside></a>
        </li>
    
        <li>
            <a href="/how-to-implement-the-scroll-and-paging-in-python-curses">파이썬 curses에서 스크롤 및 페이징 기능 구현하기<aside class="dates">Mar 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/translation-avoiding-memory-leak-in-golang-api">[번역] Go API에서 메모리 누수 예방하기<aside class="dates">Feb 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/getting-started-with-oauth2-in-go">Go에서 OAuth2 인증하기<aside class="dates">Feb 1 2018</aside></a>
        </li>
    
        <li>
            <a href="/cgo-cross-compile-for-mac-for-linux">맥에서 리눅스로 CGO 라이브러리 크로스 컴파일하기<aside class="dates">Dec 11 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-cpython-internals-arbitrary-precision-integer-implementation">[번역] 파이썬 내부 동작 원리: 임의 정밀도의 정수 구현<aside class="dates">Oct 10 2017</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-84081627-1', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
