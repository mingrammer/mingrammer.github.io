<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">

		
		<meta property="og:title" content="DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)" />
<meta property="og:description" content="약 두 달 전에 게임 서버 인프라를 이전하면서 일부 유저 데이터를 RDB와 캐시 디비에서 AWS DynamoDB로 변환 및 이전하는 작업을 진행했었다. TMI: 이전에 작성한 I" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mingrammer.com/dynamodb-batch-retry-with-exponential-backoff/" />
<meta property="article:published_time" content="2019-06-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-06-02T00:00:00+00:00" />

		

		<meta name="generator" content="Hugo 0.74.3" />
		<title>DynamoDB 배치 작업 재시도 구현 (Exponential Backoff) &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
		<link rel="stylesheet" href="https://mingrammer.com/css/custom.css">
		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)
                    </h1>
                    <h2 class="headline">
                    Jun 2, 2019 00:00
                    · 4077 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/aws">aws</a>
                          
                              <a href="https://mingrammer.com/tags/dynamodb">dynamodb</a>
                          
                              <a href="https://mingrammer.com/tags/batchjob">batchjob</a>
                          
                              <a href="https://mingrammer.com/tags/pattern">pattern</a>
                          
                              <a href="https://mingrammer.com/tags/cloud">cloud</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
  <ul>
    <li><a href="#dynamodb-exponential-backoff-재시도-구현하기">DynamoDB Exponential Backoff 재시도 구현하기</a></li>
    <li><a href="#세션-및-dynamodb-구조체-생성">세션 및 DynamoDB 구조체 생성</a></li>
    <li><a href="#재시도-가능한-쓰기-배치-메서드-작성">재시도 가능한 쓰기 배치 메서드 작성</a></li>
    <li><a href="#재시도-가능한-읽기-배치-메서드-작성">재시도 가능한 읽기 배치 메서드 작성</a></li>
  </ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <p>약 두 달 전에 게임 서버 인프라를 이전하면서 일부 유저 데이터를 RDB와 캐시 디비에서 AWS DynamoDB로 변환 및 이전하는 작업을 진행했었다.</p>
<blockquote>
<p>TMI: 이전에 작성한 <a href="/redis-migration">IDC에서 AWS로 데이터 이전하기</a>라는 포스팅에서는 내가 담당하고 있는 두 개의 게임중 한 게임의 데이터 이전에 대한 후기를 공유했었다. 당시 이전을 진행한 게임은 작년 11월에 이전이 완료되었고, 그 이후로도 다른 한 게임의 인프라 이전 또한 진행이되어 올해 4월 초에 이전이 완료되었다.</p>
<p>같은 인프라 이전이지만 두 게임은 서로 마이그레이션 요구사항이 달랐기 때문에 많은 부분이 서로 다른 방식으로 진행되었다. 그 중 특히 데이터 이전의 경우, 첫 번째 게임은 데이터 스키마와 데이터 스토어가 이전과 동일했던 반면, 두 번째 게임은 거의 대부분의 유저 데이터 스키마가 변경되었고 그에 따라 사용하게될 데이터 스토어 또한 달라졌다.</p>
</blockquote>
<p>수억건에 달하는 많은 양의 데이터를 최대한 빠른 시간안에 이전해야했기 때문에 프로비저닝 모드가 아닌 온디맨드 모드로 배치 작업을 수행했다. 실행 후 얼마 지나지 않아 예상대로 배치 작업의 속도에 비례해서 다량의 스로틀링이 발생하고 있었다. DynamoDB는 온디맨드 모드여도 최대 **WCU (Write Capacity Unit)**에 한계치가 있어서 그 이상을 넘어가면 스로틀링이 발생하는건 자연스러웠기 때문에 스로틀링 자체는 문제가 되지 않았다. 다만, 스로틀링이 발생하고 있음에도 불구하고 데이터가 예상보다 훨씬 빠른 속도로 들어가고 있는게 조금 의아했었다.</p>
<p>모니터링중 초당 삽입되는 개수와 현재 처리중인 데이터의 인덱스가 안맞는게 이상해서 중간에 작업을 중단하고 속도 대비 예상 데이터 개수와 실제로 저장된 데이터 개수를 비교해봤는데, 역시나 실제로 들어간 데이터 개수는 예상치보다 훨씬 부족한 상태였다. 즉, 중간에 다량의 데이터 쓰기 작업이 실패한셈이다.</p>
<p>디버깅을 해보니 쓰기 요청 속도가 일정 수준을 넘어가는 순간 위와 같은 문제가 발생하기 시작했다. 배치 작업을 요청하는 부분에서 문제가 발생하고 있어 관련 문서를 찾아보니 DynamoDB는 배치 작업 처리시 하나의 요청이라도 성공하면 일부 요청이 실패해도 에러를 반환하지 않고 실패한 요청에 대한 키 또는 값을 다시 반환해준다는 내용을 볼 수 있었다.</p>
<p>요청이 아예 실패하는 케이스에 대한 에러 처리는 하고 있었으나 부분 실패에 대한 처리가 빠져있어 일부 실패한 쓰기 요청들이 모두 무시되면서 데이터가 누락되는 문제가 발생했던 것이다. (결국엔 문서를 제대로 안본게 문제였다..)</p>
<h1 id="dynamodb-exponential-backoff-재시도-구현하기">DynamoDB Exponential Backoff 재시도 구현하기</h1>
<p>따라서 부분 실패가 발생하면 반환된 키 또는 값으로 다시 배치 작업을 요청하는 재시도 로직을 구현하기로했다. 재시도 전략으로는 공식 문서에서도 권장하고 있는 지수 백오프 (Exponential Backoff) 알고리즘을 사용했다. 지수 백오프 알고리즘은 매우 간단한 알고리즘으로 실패할때마다 (또는 특정 피드백을 받을때마다) 다음 요청까지의 유휴시간 간격을 n배씩 늘리면서 재요청을 지연시키는 알고리즘이다. 이 알고리즘은 TCP 전송 재시도에서부터 다양한 요청 실패의 가능성을 내재하고있는 서비스에서 재시도 전략으로 채택하고 있는 알고리즘이다. (AWS의 다양한 서비스 또는 SDK에서 내부적으로 구현하고 있는 재시도 로직에서도 같은 알고리즘을 사용한다)</p>
<p>일반적으로 <strong>n=2</strong> (Binary Exponential Backoff)를 사용하며 내 경우도 같은 값을 사용했다. 그럼 간단한 지수 백오프를 사용한 DynamoDB 재시도 로직을 구현해보자. 이 포스팅에서는 Go를 기준으로 설명한다.</p>
<h1 id="세션-및-dynamodb-구조체-생성">세션 및 DynamoDB 구조체 생성</h1>
<p>우선 AWS 자격 인증을 통해 세션을 생성하고 DynamoDB 서비스 객체를 초기화한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;errors&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;math&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>

    <span class="s">&#34;github.com/aws/aws-sdk-go/aws&#34;</span>
    <span class="s">&#34;github.com/aws/aws-sdk-go/aws/credentials&#34;</span>
    <span class="s">&#34;github.com/aws/aws-sdk-go/aws/session&#34;</span>
    <span class="s">&#34;github.com/aws/aws-sdk-go/service/dynamodb&#34;</span>
    <span class="s">&#34;github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute&#34;</span>
<span class="p">)</span>

<span class="c1">// DynamoDB 구조체는 테이블명, 키 리스트, 서비스 객체 (service/dynamodb)를 관리
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DynamoDB</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">table</span> <span class="kt">string</span>
    <span class="nx">conn</span>  <span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">DynamoDB</span>
<span class="p">}</span>

<span class="c1">// AWS 인증키 및 설정값 (실사용시 인증키는 하드코딩하지 않는다)
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">awsAccessKeyID</span>     <span class="p">=</span> <span class="s">&#34;AKXXXXXXXXXXXXXXXXXX&#34;</span>
    <span class="nx">awsSecretAccessKey</span> <span class="p">=</span> <span class="s">&#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#34;</span>
    <span class="nx">awsRegion</span>          <span class="p">=</span> <span class="s">&#34;ap-northeast-2&#34;</span>
<span class="p">)</span>

<span class="c1">// 자격 인증 및 세션 생성
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewSession</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">session</span><span class="p">.</span><span class="nx">Session</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sess</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">session</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">aws</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
        <span class="nx">Region</span><span class="p">:</span>      <span class="nx">aws</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">awsRegion</span><span class="p">),</span>
        <span class="nx">Credentials</span><span class="p">:</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewStaticCredentials</span><span class="p">(</span><span class="nx">awsAccessKeyID</span><span class="p">,</span> <span class="nx">awsSecretAccessKey</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;failed to create an aws session&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sess</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 서비스 객체 생성 및 DynamoDB 구조체 초기화
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewDynamoDB</span><span class="p">(</span><span class="nx">table</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">DynamoDB</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sess</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewSession</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">ddb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">DynamoDB</span><span class="p">{</span>
        <span class="nx">table</span><span class="p">:</span> <span class="nx">table</span><span class="p">,</span>
        <span class="nx">conn</span><span class="p">:</span> <span class="nx">dynamodb</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">sess</span><span class="p">,</span> <span class="kc">nil</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ddb</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>그럼 이제 DynamoDB 구조체에 부분 실패시 재시도를 수행해주는 배치 작업 메서드를 작성해보자.</p>
<h1 id="재시도-가능한-쓰기-배치-메서드-작성">재시도 가능한 쓰기 배치 메서드 작성</h1>
<p>재시도 가능한 쓰기 배치 작업은 다음과 같은 플로우로 진행된다.</p>
<ul>
<li>빌트인 자료구조로 표현된 값을 DynamoDB 속성값으로 변환</li>
<li>변환된 값으로 쓰기 요청 생성</li>
<li>쓰기 요청값으로 배치 작업 수행</li>
<li>부분 요청 실패시 일정 시간 대기하고 반환된 값으로 배치 작업 재수행</li>
<li>모든 요청이 성공하면 종료</li>
</ul>
<p><code>RetryableBatchWrite</code>는 쓰기 배치 메서드로 <strong>키-값</strong> 리스트를 인자로 받고 에러를 반환한다. DynamoDB가 지원하는 쓰기 배치는 한 번에 요청할 수 있는 아이템의 개수를 최대 25개로 제한하기 때문에 길이부터 검증한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// items = [
</span><span class="c1">//     {
</span><span class="c1">//         &#34;k1&#34;: &#34;v1&#34;,
</span><span class="c1">//         &#34;k2&#34;: &#34;v2&#34;,
</span><span class="c1">//     },
</span><span class="c1">//     {
</span><span class="c1">//         &#34;k3&#34;: &#34;v3&#34;,
</span><span class="c1">//         &#34;k4&#34;: &#34;v4&#34;,
</span><span class="c1">//     },
</span><span class="c1">// ]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ddb</span> <span class="o">*</span><span class="nx">DynamoDB</span><span class="p">)</span> <span class="nf">RetryableBatchWrite</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;you must pass at least one item&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;you must pass items less than or equal to number of 25&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>인자로 받은 <code>키-값</code>의 <code>값</code>을 DynamoDB 속성값으로 인코딩 (마샬링)한 뒤, DynamoDB API로 넘길 쓰기 요청을 만든다. (<code>dynamodb.WriteRequest</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ddb</span> <span class="o">*</span><span class="nx">DynamoDB</span><span class="p">)</span> <span class="nf">RetryableBatchWrite</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 쓰기 요청용 구조체
</span><span class="c1"></span>    <span class="nx">req</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">WriteRequest</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
        <span class="nx">putItem</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">AttributeValue</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">item</span> <span class="p">{</span>
            <span class="c1">// 값을 DynamoDB 속성값으로 인코딩
</span><span class="c1"></span>            <span class="nx">attr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dynamodbattribute</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">err</span>
            <span class="p">}</span>
            <span class="nx">putItem</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">attr</span>
        <span class="p">}</span>
        <span class="c1">// 쓰기 요청 목록에 &#34;키-값&#34;을 PutRequest로 추가 (쓰기에는 Put/Delete 두 종류의 타입이 있음)
</span><span class="c1"></span>        <span class="nx">req</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">WriteRequest</span><span class="p">{</span>
            <span class="nx">PutRequest</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">PutRequest</span><span class="p">{</span>
                <span class="nx">Item</span><span class="p">:</span> <span class="nx">putItem</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">})</span>
    <span class="p">}</span>
    <span class="c1">// 인코딩이 완료되면 {테이블명: 쓰기 요청 객체} 맵을 만든다
</span><span class="c1"></span>    <span class="c1">// 배치 작업 실패시 반환되는 값과 동일한 포맷이다
</span><span class="c1"></span>    <span class="nx">unprocessed</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">WriteRequest</span><span class="p">{</span>
        <span class="nx">ddb</span><span class="p">.</span><span class="nx">table</span><span class="p">:</span> <span class="nx">req</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>다음으로, 위에서 만든 쓰기 요청으로 실제 배치 작업을 수행한다. 배치 작업을 요청하기 전에 재시도 횟수 카운터 변수인 <code>attempts</code>를 선언한다. <code>attempts</code>가 0보다 커지면 재시도를 수행하고 최대 재시도 횟수 안에 모든 요청을 처리하지 못하면 에러를 반환하도록 한다.</p>
<p>재시도 관련 상수값은 애플리케이션에 맞게 적절한 값으로 설정하면 된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">maxRetries</span>      <span class="p">=</span> <span class="mi">10</span>
    <span class="nx">minRetryBackoff</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
    <span class="nx">maxRetryBackoff</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ddb</span> <span class="o">*</span><span class="nx">DynamoDB</span><span class="p">)</span> <span class="nf">RetryableBatchWrite</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">attempts</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 재시도 수행시 재시도 횟수만큼 대기시간을 늘리면서 요청을 지연시킨다
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">attempts</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nf">RetryBackoff</span><span class="p">(</span><span class="nx">attempts</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nx">attempts</span><span class="o">++</span>
        <span class="c1">// 배치 작업 수행
</span><span class="c1"></span>        <span class="nx">output</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ddb</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">BatchWriteItem</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">BatchWriteItemInput</span><span class="p">{</span>
            <span class="nx">RequestItems</span><span class="p">:</span> <span class="nx">unprocessed</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="c1">// 일부 요청이 실패한 경우 unprocessed의 테이블키에 쓰기 요청을 담아서 반환해준다
</span><span class="c1"></span>        <span class="c1">// 모든 요청이 성공하면 empty map을 반환한다
</span><span class="c1"></span>        <span class="c1">// if _, ok := unprocessed[ddb.table]; !ok를 사용해도 된다
</span><span class="c1"></span>        <span class="nx">unprocessed</span> <span class="p">=</span> <span class="nx">output</span><span class="p">.</span><span class="nx">UnprocessedItems</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">unprocessed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 최대 재시도 횟수를 넘기면 에러 반환
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">attempts</span> <span class="p">&gt;</span> <span class="nx">maxRetries</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;reached maximum retry attempts&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 재시도 수행
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><code>RetryBackoff</code> 함수는 다음과 같이 구현할 수 있다. 재시도 횟수만큼 최대 시간에 도달할 때까지 2배씩 늘린다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RetryBackoff</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
    <span class="nx">rb</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="o">*</span> <span class="nx">minRetryBackoff</span>
    <span class="k">if</span> <span class="nx">rb</span> <span class="p">&gt;</span> <span class="nx">maxRetryBackoff</span> <span class="p">{</span>
        <span class="nx">rb</span> <span class="p">=</span> <span class="nx">maxRetryBackoff</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">rb</span>
<span class="p">}</span>
</code></pre></div><p>이제 위에서 구현한 재시도 가능한 쓰기 배치 메서드가 잘 동작하는지 확인해보기 위해 테스트용 테이블로 <code>id</code>와 <code>stage</code>를 각각 파티션키, 정렬키로 갖는 <code>user</code> 테이블을 만들고 <strong>2,500</strong>개의 데이터를 배치로 넣는 코드를 작성해보자. 테스트는 <code>50 RCU / 50 WCU</code> 환경에서 진행되었다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// DynamoDB 초기화
</span><span class="c1"></span>    <span class="nx">ddb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewDynamoDB</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="nx">vals</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
    <span class="c1">// 2,500개 데이터 생성
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2501</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">vals</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
            <span class="s">&#34;id&#34;</span><span class="p">:</span>    <span class="mi">1</span><span class="p">,</span>
            <span class="s">&#34;stage&#34;</span><span class="p">:</span> <span class="nx">i</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="c1">// 25개씩 배치 처리
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">25</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">// 배치 고루틴 생성
</span><span class="c1"></span>            <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
                <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
                <span class="c1">// 배치 작업 수행
</span><span class="c1"></span>                <span class="c1">// 테스트 코드에서는 에러를 무시하고 있지만 실사용시에는 적절한 에러처리가 필요하다
</span><span class="c1"></span>                <span class="nx">_</span> <span class="p">=</span> <span class="nx">ddb</span><span class="p">.</span><span class="nf">RetryableBatchWrite</span><span class="p">(</span><span class="nx">vals</span><span class="p">)</span>
            <span class="p">}(</span><span class="nx">vals</span><span class="p">)</span>
            <span class="nx">vals</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>재시도가 정상적으로 동작하는지 확인하기 위해 요청 간격을 지연시키는 부분에 간단한 로깅을 추가하자.</p>
<pre><code>if attempts &gt; 0 {
    time.Sleep(RetryBackoff(attempts))
    fmt.Println(fmt.Sprintf(&quot;attempts: %d, left: %d&quot;, attempts, len(unprocessed[ddb.table])))
}
</code></pre><p>이제 위 코드를 돌려보면 다음과 같은 재시도 요청들을 볼 수 있으며, 데이터도 실제로 잘 들어감을 확인할 수 있다. (고루틴과 DynamoDB에서의 쓰기 요청이 실제로 어떻게 처리되느냐에 따라 재시도 동작 및 출력값은 매번 다를 수 있다)</p>
<pre><code class="language-console" data-lang="console">attempts: 1, left: 11
attempts: 1, left: 23
attempts: 1, left: 6
attempts: 1, left: 10
attempts: 1, left: 10
...
attempts: 3, left: 9
attempts: 5, left: 7
attempts: 4, left: 5
attempts: 4, left: 6
attempts: 5, left: 4
attempts: 4, left: 5
attempts: 6, left: 5
</code></pre><h1 id="재시도-가능한-읽기-배치-메서드-작성">재시도 가능한 읽기 배치 메서드 작성</h1>
<p>재시도 가능한 읽기 배치 코드는 다음과 같으며 플로우는 쓰기 배치와 동일하므로 과정은 생략하고 차이점만 나열하겠다.</p>
<ul>
<li><code>키-값</code> 리스트 대신 <code>키</code> 리스트를 인자로 받음</li>
<li>에러와 함께 받아온 데이터를 반환</li>
<li>한 번에 요청할 수 있는 키의 개수가 100개임</li>
<li>쓰기의 경우 인코딩한 데이터를 각각 <code>WriteRequest</code>에 <code>PutRequest</code> 형태로 담고, 읽기의 경우 인코딩한 키들을 <code>KeysAndAttribute</code>의 <code>Keys</code>에 한 번에 담는다</li>
<li><code>UnprocessedItems</code> 대신 <code>UnprocessedKeys</code>로 실패값(키) 처리</li>
<li><code>unprocessed[ddb.table]</code> 대신 <code>unprocessed[ddb.table].Keys</code>에 실패값(키)가 담겨져 있음</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// keys = [
</span><span class="c1">//     {
</span><span class="c1">//         &#34;k1&#34;: &#34;v1&#34;,
</span><span class="c1">//         &#34;k2&#34;: &#34;v2&#34;,
</span><span class="c1">//     },
</span><span class="c1">//     {
</span><span class="c1">//         &#34;k3&#34;: &#34;v3&#34;,
</span><span class="c1">//         &#34;k4&#34;: &#34;v4&#34;,
</span><span class="c1">//     },
</span><span class="c1">// ]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ddb</span> <span class="o">*</span><span class="nx">DynamoDB</span><span class="p">)</span> <span class="nf">RetryableBatchGet</span><span class="p">(</span><span class="nx">keys</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">([]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;you must pass at least one key&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;you must pass keys less than or equal to number of 100&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 키 저장용 구조체
</span><span class="c1"></span>    <span class="nx">attrKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">AttributeValue</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
        <span class="nx">attrKey</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">AttributeValue</span><span class="p">{}</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">key</span> <span class="p">{</span>
            <span class="c1">// 값을 DynamoDB 속성값으로 인코딩
</span><span class="c1"></span>            <span class="nx">marshaled</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dynamodbattribute</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
            <span class="p">}</span>
            <span class="nx">attrKey</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">marshaled</span>
        <span class="p">}</span>
        <span class="nx">attrKeys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">attrKeys</span><span class="p">,</span> <span class="nx">attrKey</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 키 목록 추가
</span><span class="c1"></span>    <span class="nx">unprocessed</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">KeysAndAttributes</span><span class="p">{</span>
        <span class="nx">ddb</span><span class="p">.</span><span class="nx">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">KeysAndAttributes</span><span class="p">{</span>
            <span class="nx">Keys</span><span class="p">:</span> <span class="nx">attrKeys</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="c1">// 받아온 데이터 저장용 변수
</span><span class="c1"></span>    <span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
    <span class="nx">attempts</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span>
         <span class="c1">// 재시도 수행시 재시도 횟수만큼 대기시간을 늘리면서 요청을 지연시킨다
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">attempts</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nf">RetryBackoff</span><span class="p">(</span><span class="nx">attempts</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nx">attempts</span><span class="o">++</span>
        <span class="c1">// 배치 작업 수행
</span><span class="c1"></span>        <span class="nx">output</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ddb</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">BatchGetItem</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dynamodb</span><span class="p">.</span><span class="nx">BatchGetItemInput</span><span class="p">{</span>
            <span class="nx">RequestItems</span><span class="p">:</span> <span class="nx">unprocessed</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="c1">// 받아온 데이터 디코딩
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">output</span><span class="p">.</span><span class="nx">Responses</span><span class="p">[</span><span class="nx">ddb</span><span class="p">.</span><span class="nx">table</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">item</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
            <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
                <span class="c1">// DynamoDB 속성값 디코딩
</span><span class="c1"></span>                <span class="nx">dynamodbattribute</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">val</span><span class="p">)</span>
                <span class="nx">item</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">val</span>
            <span class="p">}</span>
            <span class="nx">items</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 일부 요청이 실패한 경우 unprocessed의 테이블키에 실패한 키를 담아서 반환해준다
</span><span class="c1"></span>        <span class="c1">// 모든 요청이 성공하면 empty map을 반환한다
</span><span class="c1"></span>        <span class="c1">// if _, ok := unprocessed[ddb.table]; !ok를 사용해도 된다
</span><span class="c1"></span>        <span class="nx">unprocessed</span> <span class="p">=</span> <span class="nx">output</span><span class="p">.</span><span class="nx">UnprocessedKeys</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">unprocessed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 최대 재시도 횟수를 넘기면 에러 반환
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">attempts</span> <span class="p">&gt;</span> <span class="nx">maxRetries</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;reached maximum retry attempts&#34;</span><span class="p">)</span>
        <span class="p">}</span>
         <span class="c1">// 재시도 수행
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>읽기 배치의 재시도 테스트도 해보자. 읽기의 경우 쓰기보다 빠르게 처리되므로 스로틀링이 잘 걸리도록 <strong>RCU</strong>와 <strong>WCU</strong>를 의도적으로 <code>10</code>으로 낮췄다. 실제 상황에서 데이터 요청이 매우 많은 경우에는 <strong>RCU</strong>, <strong>WCU</strong>가 충분히 높아도 스로틀링이 걸릴 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// DynamoDB 초기화
</span><span class="c1"></span>    <span class="nx">ddb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewDynamoDB</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="nx">keys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2501</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
            <span class="s">&#34;id&#34;</span><span class="p">:</span>    <span class="mi">1</span><span class="p">,</span>
            <span class="s">&#34;stage&#34;</span><span class="p">:</span> <span class="nx">i</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="c1">// 100개씩 배치 처리
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">// 배치 고루틴 생성
</span><span class="c1"></span>            <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">k</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
                <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
                <span class="c1">// 배치 작업 수행
</span><span class="c1"></span>                <span class="c1">// 배치 데이터를 한 번에 처리하려면 items를 고루틴 밖에서 취합하는 별도의 작업이 필요하다
</span><span class="c1"></span>                <span class="nx">items</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ddb</span><span class="p">.</span><span class="nf">RetryableBatchGet</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
                <span class="c1">// 테스트 로깅
</span><span class="c1"></span>                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">))</span>
            <span class="p">}(</span><span class="nx">keys</span><span class="p">)</span>
            <span class="nx">keys</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>쓰기 배치에서와 동일하게 로깅을 심어보면 다음과 같은 재시도 요청들을 볼 수 있다. 받아온 데이터는 위의 쓰기 배치 테스트시 넣어둔 데이터이다.</p>
<pre><code class="language-console" data-lang="console">...
100
100
attempts: 1, unprocessed: 18
100
100
100
100
100
attempts: 1, unprocessed: 18
100
100
...
</code></pre><p>읽기 배치 또한 잘 동작하는걸 확인할 수 있다.</p>
<p>배치 메서드를 사용하는 부분을 보면 개수 제한과 병렬 처리 때문에 다소 복잡해보이는데 이 부분은 한 메서드로 처리할 수 있도록 한 번 더 래핑해서 사용하면 좀 더 깔끔하게 사용할 수 있다.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2fdynamodb-batch-retry-with-exponential-backoff%2f - DynamoDB%20%eb%b0%b0%ec%b9%98%20%ec%9e%91%ec%97%85%20%ec%9e%ac%ec%8b%9c%eb%8f%84%20%ea%b5%ac%ed%98%84%20%28Exponential%20Backoff%29 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
            <div class="adsense">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                
                <ins class="adsbygoogle"
                    style="display:block"
                    data-ad-client="ca-pub-9436560391944255"
                    data-ad-slot="5717491307"
                    data-ad-format="auto"
                    data-full-width-responsive="true"></ins>
                <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>
            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/go-modules-private-repo">Go 프라이빗 모듈 가져오기<aside class="dates">Apr 18 2020</aside></a>
        </li>
    
        <li>
            <a href="/debugging-containerized-go-app">컨테이너 내부 Go 애플리케이션 디버깅하기<aside class="dates">Feb 13 2020</aside></a>
        </li>
    
        <li>
            <a href="/debug-memory-leak-with-node-heapdump">푸시 데몬 메모리 누수 디버깅하기<aside class="dates">Nov 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/scheduling-cron-job-in-seconds-interval">Cron에서 초단위로 스케줄링하기<aside class="dates">Aug 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/redis-migration">IDC에서 AWS로 Redis 데이터 이전하기<aside class="dates">Feb 1 2019</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-7">[Go로 구현하는 블록체인] Part 7: 네트워크<aside class="dates">Jun 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-3">[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI<aside class="dates">May 22 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-84081627-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
