<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">

		
		<meta property="og:title" content="[Go로 구현하는 블록체인] Part 7: 네트워크" />
<meta property="og:description" content="Building Blockchain in Go 시리즈를 번역한 글입니다. 서론 지금까지 우리는 익명의 안전하고 무작위로 생성된 주소, 블록체인 데이터 저장소, 작업 증명 시스템, 신뢰할 수 있는 트랜잭" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mingrammer.com/building-blockchain-in-go-part-7/" />
<meta property="article:published_time" content="2018-06-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-06-18T00:00:00+00:00" />

		

		<meta name="generator" content="Hugo 0.69.0" />
		<title>[Go로 구현하는 블록체인] Part 7: 네트워크 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
		<link rel="stylesheet" href="https://mingrammer.com/css/custom.css">
		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [Go로 구현하는 블록체인] Part 7: 네트워크
                    </h1>
                    <h2 class="headline">
                    Jun 18, 2018 00:00
                    · 6836 words
                    · 14 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/blockchain">blockchain</a>
                          
                              <a href="https://mingrammer.com/tags/network">network</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
  <ul>
    <li><a href="#서론">서론</a></li>
    <li><a href="#블록체인-네트워크">블록체인 네트워크</a></li>
    <li><a href="#노드의-역할">노드의 역할</a></li>
    <li><a href="#네트워크-단순화">네트워크 단순화</a></li>
    <li><a href="#구현">구현</a>
      <ul>
        <li><a href="#시나리오">시나리오</a></li>
        <li><a href="#버전">버전</a></li>
        <li><a href="#getblocks">getblocks</a></li>
        <li><a href="#inv">inv</a></li>
        <li><a href="#getdata">getdata</a></li>
        <li><a href="#block과-tx">block과 tx</a></li>
      </ul>
    </li>
    <li><a href="#결과">결과</a></li>
    <li><a href="#결론">결론</a></li>
  </ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <blockquote>
<p><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-7">Building Blockchain in Go</a> 시리즈를 번역한 글입니다.</p>
</blockquote>
<h1 id="서론">서론</h1>
<p>지금까지 우리는 익명의 안전하고 무작위로 생성된 주소, 블록체인 데이터 저장소, 작업 증명 시스템, 신뢰할 수 있는 트랜잭션 저장 방법등의 핵심 기능들을 모두 갖춘 블록체인을 만들었다. 이 기능들도 물론 중요하지만 아직 부족하다. 이 기능들을 실제로 빛나게하고 암호화 화폐를 가능케 하는것은 바로 네트워크이다. 이러한 블록체인을 하나의 컴퓨터에서만 실행하면 무슨 소용인가? 단 한 명의 사용자만 있다면 이러한 암호화 기반의 기능들이 무슨 소용인가? 이 메커니즘들을 작동시키고 유용하게 만드는건 네트워크이다.</p>
<p>이러한 블록체인의 기능들은 하나의 규칙으로 생각할 수 있다. 사람들이 함께 살고 번영하고 싶어서 세우는 사회 질서의 규칙들과 유사하다. 블록체인 네트워크는 네트워크를 활성화시키는 동일한 규칙을 따르는 프로그램들의 커뮤니티이다. 마찬가지로, 사람들이 똑같은 생각을 공유할 때 그들은 강해지고 함께 더 나은 삶을 살 수 있다. 사람들이 서로 다른 규칙을 따르면 그들은 분리된 사회에서 살게된다. 이와 동일하게, 블록체인 노드들이 서로 다른 규칙을 따르면 이는 분리된 네트워크를 형성하게 될 것이다.</p>
<p><strong>매우 중요함:</strong> 네트워크가 없고 대다수의 노드가 동일한 규칙을 공유하지 않는다면 이러한 규칙들은 쓸모가 없다.</p>
<blockquote>
<p>아쉽게도, 필자는 P2P 네트워크 프로토타입을 구현할 시간이 없었다. 이 파트에서는 서로 다른 타입의 노드를 포함하는 가장 일반적인 시나리오 하나를 시연해볼 것이다. 이 시나리오를 개선하고 P2P 네트워크를 구현해보는건 여러분에게 훌륭한 도전거리가 될 것이다. 또한, 이 파트에서 구현한 네트워크가 시연할 시나리오 이외의 시나리오에서도 잘 동작할지는 보장할 수 없다. 이 부분은 죄송하다!</p>
<p>이 파트에서는 중요한 코드 변경사항을 소개하기 때문에 모든 코드를 설명하는건 의미가 없다. 모든 변경사항은 <a href="https://github.com/Jeiwan/blockchain_go/compare/part_6...part_7#files_bucket">여기</a>를 참조하라.</p>
</blockquote>
<h1 id="블록체인-네트워크">블록체인 네트워크</h1>
<p>블록체인 네트워크는 분산되어있어 작업을 수행하는 서버와 서버에서 데이터를 가져와 처리하는 클라이언트가 따로 없다. 블록체인 네트워크에는 노드가 존재하며 각 노드들은 네트워크의 일원으로서 자격을 지닌다. 노드는 클라이언트이자 서버이다. 일반적인 웹 애플리케이션과 매우 다르기 때문에 꼭 명심하길 바란다.</p>
<p>블록체인 네트워크는 P2P (Peer-to-Peer) 네트워크기 때문에 노드들은 서로 직접 연결되어있다. 이 구조의 토폴로지는 평면인데 노드 역할에는 계층이 없기 때문이다. 이를 도식화하면 다음과 같다.</p>
<p><img src="../images/2018-06-18-p2p-network.png" alt="P2P Network"></p>
<p>이러한 네트워크의 노드는 많은 연산을 수행해야하기 때문에 구현하기가 더욱 까다롭다. 각 노드는 다른 여러 노드들과 상호작용 해야하며, 다른 노드의 상태를 요청하고 자신의 상태와 비교해 오래된 값이면 상태를 업데이트 해야한다.</p>
<h1 id="노드의-역할">노드의 역할</h1>
<p>블록체인의 노드들은 모두 완전한 기능을 갖추고 있지만 네트워크에서 서로 다른 역할을 수행할 수 있다. 역할은 다음과 같다.</p>
<ol>
<li>
<p>채굴 노드: 채굴 노드는 ASIC과 같은 강력하고 특수한 하드웨어 위에서 동작하며, 이 노드들의 유일한 목적은 새로운 블록을 가능한한 빠르게 채굴하는 것이다. 채굴 노드는 작업 증명 시스템을 사용하는 블록체인에서만 가능하다. 채굴이란게 실제로는 PoW 퍼즐을 푸는 일이기 때문이다. 한 예로, 지분 증명 (Proof-of-Stake) 블록체인에는 채굴이 없다.</p>
</li>
<li>
<p>풀 노드: 이 노드는 채굴 노드에 의해 채굴된 블록의 유효성을 확인하고 트랜잭션을 검증한다. 이 작업을 위해선 블록체인의 전체 복제본이 필요하다. 또한 이 노드는 다른 노드들이 서로를 찾을 수 있도록 돕는일과 같은 라우팅 연산을 수행하기도 한다.
풀 노드는 블록 및 트랜잭션의 유효성을 검사하고 의사결정을 하는 노드이기 때문에 네트워크는 많은 풀 노드를 갖는게 중요하다.</p>
</li>
<li>
<p>SPV: SPV는 Simplified Payment Verification의 약자이다. 이 노드는 블록체인의 전체 복사본을 저장하고 있지는 않지만 트랜잭션 검증은 가능하다 (단, 모든 검증 작업이 가능한건 아니며 일부만 가능하다. 예를 들어, 어떤 트랜잭션이 특정 주소에서 전송되었는지 확인하는 검증은 가능하다). SPV 노드는 풀 노드로부터 데이터를 얻어오며 하나의 풀 노드에 여러개의 SPV 노드가 연결될 수 있다. SPV는 지갑 애플리케이션을 가능케한다. 개인은 전체 블록체인을 다운로드 받을 필요는 없으나 여전히 트랜잭션을 검증할 수 있다.</p>
</li>
</ol>
<h1 id="네트워크-단순화">네트워크 단순화</h1>
<p>우리가 만든 블록체인에서 네트워크를 구현하기 위해선 일부 기능들을 단순화 시켜야한다. 한 가지 문제는 다수의 노드를 가진 네트워크를 시뮬레이션 하기 위해 필요한 충분한 수의 컴퓨터를 가지고 있지 않다는 것이다. 이 문제를 해결하기 위해 가상머신이나 도커를 사용할 수도 있지만 되려 더 어려워질 수가 있다. 블록체인 구현에만 집중하는게 목표인데 가상머신이나 도커를 사용하면서 발생할 수 있는 이슈를 해결해야할 수도 있기 때문이다. 따라서 우리는 하나의 머신에서 여러 블록체인 노드를 동시에 실행하여 각 노드에 서로 다른 주소를 할당해 사용할 것이다. 이를 위해 IP 주소 대신 <strong>포트를 노드 식별자</strong>로 사용할 것이다. 예로 <strong>127.0.0.1:3000</strong>, <strong>127.0.0.1:3001</strong>, <strong>127.0.0.1:3002</strong> 등의 주소를 가진 노드가 있을 수 있다. 우리는 포트를 노드 ID로 두고 <strong>NODE_ID</strong> 환경 변수를 사용해 값을 설정할 것이다. 따라서, 여러대의 터미널창을 띄워 서로 다른 <strong>NODE_ID</strong>를 설정해 독립된 노드들을 실행할 수 있다.</p>
<p>이 방법을 사용하려면 서로 다른 블록체인과 지갑 파일이 필요하다. 이 파일들은 노드 ID를 사용해 <strong>blockchain_3000.db</strong>, <strong>blockchain_3001.db</strong> 및 <strong>wallet_3000.db</strong>, <strong>wallet_3001.db</strong> 등과 같이 명명할 것이다.</p>
<h1 id="구현">구현</h1>
<p>비트코인 코어를 다운로드하여 처음 실행하면 어떤 일이 일어날까? 최신 상태의 블록체인을 다운로드 받기 위해 일부 노드와 연결되어야 한다.
컴퓨터가 비트코인의 전체 또는 일부 노드를 인식하지 못한다는것을 고려할 때, 이 노드는 어떤게 될 수 있을까?</p>
<p>비트코인 코어에서 노드 주소를 하드코딩하면 잘못될 수도 있다. 노드는 공격 당하거나 종료되어 새로운 노드가 네트워크에 참여할 수 없게될 수도 있다. 비트코인 코어에서는 대신 <a href="https://bitcoin.org/en/glossary/dns-seed">DNS 시드</a>가 하드코딩 되어있다. 이는 노드가 아니며 일부 노드의 주소를 알고 있는 DNS 서버이다. 비트코인 코어를 최초로 실행하면 코어는 시드중 하나에 연결되어 블록체인을 다운로드 받을 풀 노드들의 주소가 담긴 리스트를 받아올 것이다.</p>
<p>하지만 우리의 구현에서는 중앙 집중화가 이루어질 것이다. 우리는 세 종류의 노드를 갖는다.</p>
<ol>
<li>중앙 노드: 모든 노드와 연결되어 있는 노드이며 다른 노드들간에 데이터를 전송하는 노드이다.</li>
<li>채굴자 노드: 이 노드는 새로운 트랜잭션을 mempool에 저장하며 충분한 양의 트랜잭션이 쌓이면 새로운 블록을 채굴한다.</li>
<li>지갑 노드: 이 노드는 지갑간 코인을 전송하는데 사용된다. SPV 노드와는 다르게 블록체인의 전체 복사본을 저장한다.</li>
</ol>
<h2 id="시나리오">시나리오</h2>
<p>목표는 다음 시나리오를 구현하는 것이다.</p>
<ol>
<li>중앙 노드는 블록체인을 생성한다.</li>
<li>다른 지갑 노드들은 중앙 노드에 연결되어 블록체인을 다운로드 받는다.</li>
<li>채굴자 노드들도 중앙 노드에 연결되어 블록체인을 다운로드 받는다.</li>
<li>지갑 노드는 트랜잭션을 생성한다.</li>
<li>채굴자 노드는 트랜잭션을 받아 메모리풀에 저장해둔다.</li>
<li>메모리풀에 충분한 양의 트랜잭션이 쌓이면 채굴자 노드는 새로운 블록의 채굴을 시작한다.</li>
<li>새로운 블록이 채굴되면, 중앙 노드에 전송된다.</li>
<li>지갑 노드는 중앙 노드와 동기화된다.</li>
<li>지갑 노드의 사용자는 지불이 정상적으로 이루어졌는지 확인한다.</li>
</ol>
<p>이는 비트코인에서의 시나리오와 유사하다. 물론 실제 P2P 네트워크를 구축하지는 않겠지만 비트코인의 실제로 동작하는 가장 중요한 사용 사례를 구현할 것이다.</p>
<h2 id="버전">버전</h2>
<p>노드는 메시지를 통해 통신한다. 새로운 노드가 실행되면 DNS 시드에서 여러 노드를 가져와 <strong>version</strong> 메시지를 전송한다. 메시지는 다음과 같이 구현할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">version</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Version</span>    <span class="kt">int</span>
        <span class="nx">BestHeight</span> <span class="kt">int</span>
        <span class="nx">AddrFrom</span>   <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>우리의 블록체인은 단 하나의 버전만 가지기 때문에 <strong>Version</strong> 필드는 중요하지 않다. <strong>BestHeight</strong>는 노드가 가진 블록체인의 길이를 저장한다. <strong>AddrFrom</strong>은 전송자의 주소를 저장한다.</p>
<p><strong>version</strong> 메시지를 받은 노드는 무엇을 해야할까? 이 노드는 자신의 <strong>version</strong> 메시지로 응답한다. 이는 핸드셰이크의 일종으로 서로간 인사말 메시지를 주고받기 전까진 상호작용을 할 수 없다. 이는 단순히 공손함을 표현하는게 아니다. <strong>version</strong>은 더 긴 블록체인을 찾는데 사용된다. 노드가 <strong>version</strong> 메시지를 받으면 이는 자신이 가진 블록체인이 <strong>BestHeight</strong>보다 더 긴지 확인한다. 더 짧은 경우, 노드는 누락된 블록을 요청하여 다운로드 받는다.</p>
<p>메시지를 받으려면 서버가 필요하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">nodeAddress</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">knownNodes</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;localhost:3000&#34;</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">StartServer</span><span class="p">(</span><span class="nx">nodeID</span><span class="p">,</span> <span class="nx">minerAddress</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">nodeAddress</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;localhost:%s&#34;</span><span class="p">,</span> <span class="nx">nodeID</span><span class="p">)</span>
        <span class="nx">miningAddress</span> <span class="p">=</span> <span class="nx">minerAddress</span>
        <span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="nx">protocol</span><span class="p">,</span> <span class="nx">nodeAddress</span><span class="p">)</span>
        <span class="k">defer</span> <span class="nx">ln</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

        <span class="nx">bc</span> <span class="o">:=</span> <span class="nf">NewBlockchain</span><span class="p">(</span><span class="nx">nodeID</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">nodeAddress</span> <span class="o">!=</span> <span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
                <span class="nf">sendVersion</span><span class="p">(</span><span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">bc</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ln</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
                <span class="k">go</span> <span class="nf">handleConnection</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">bc</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>먼저 중앙 노드의 주소를 하드코딩한다. 모든 노드는 처음에 연결할 노드를 알아야한다. <strong>minerAddress</strong> 인자는 채굴 보상을 받을 주소를 지정한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">nodeAddress</span> <span class="o">!=</span> <span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="nf">sendVersion</span><span class="p">(</span><span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">bc</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>현재 노드가 중앙 노드가 아니면 자신의 블록체인이 최신 데이터인지 확인하기위해 중앙 노드에 <strong>version</strong> 메시지를 전송해야한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sendVersion</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">bestHeight</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">GetBestHeight</span><span class="p">()</span>
        <span class="nx">payload</span> <span class="o">:=</span> <span class="nf">gobEncode</span><span class="p">(</span><span class="nx">version</span><span class="p">{</span><span class="nx">nodeVersion</span><span class="p">,</span> <span class="nx">bestHeight</span><span class="p">,</span> <span class="nx">nodeAddress</span><span class="p">})</span>

        <span class="nx">request</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nf">commandToBytes</span><span class="p">(</span><span class="s">&#34;version&#34;</span><span class="p">),</span> <span class="nx">payload</span><span class="o">...</span><span class="p">)</span>
        <span class="nf">sendData</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>메시지는 로우 레벨에서 보면 바이트의 시퀀스이다. 첫 12 바이트는 커맨드명 (여기선 &ldquo;version&rdquo;)을 나타내며 이어지는 바이트는 <strong>gob</strong>으로 인코딩된 메시지 구조체이다. <strong>commandToBytes</strong>는 다음과 같이 구현한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">commandToBytes</span><span class="p">(</span><span class="nx">command</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">bytes</span> <span class="p">[</span><span class="nx">commandLength</span><span class="p">]</span><span class="kt">byte</span>

        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">command</span> <span class="p">{</span>
                <span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">bytes</span><span class="p">[:]</span>
<span class="p">}</span>
</code></pre></div><p>이 함수는 12 바이트의 버퍼를 만들어 커맨드명을 채워넣은 뒤 나머지 바이트는 빈 상태 그대로 둔다. 반대로 바이트 시퀀스를 커맨드로 변환하는 함수도 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bytesToCommand</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">command</span> <span class="p">[]</span><span class="kt">byte</span>

        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bytes</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">b</span> <span class="o">!=</span> <span class="mh">0x0</span> <span class="p">{</span>
                        <span class="nx">command</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">command</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>노드가 커맨드를 수신하면, <strong>bytesToCommand</strong>를 통해 커맨드명을 가져와 적절한 핸들러로 커맨드 내용을 처리한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleConnection</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
        <span class="nx">command</span> <span class="o">:=</span> <span class="nf">bytesToCommand</span><span class="p">(</span><span class="nx">request</span><span class="p">[:</span><span class="nx">commandLength</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received %s command\n&#34;</span><span class="p">,</span> <span class="nx">command</span><span class="p">)</span>

        <span class="k">switch</span> <span class="nx">command</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="s">&#34;version&#34;</span><span class="p">:</span>
                <span class="nf">handleVersion</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">bc</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unknown command!&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><strong>version</strong> 커맨드 핸들러는 다음과 같다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleVersion</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">buff</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
        <span class="kd">var</span> <span class="nx">payload</span> <span class="nx">version</span>

        <span class="nx">buff</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">request</span><span class="p">[</span><span class="nx">commandLength</span><span class="p">:])</span>
        <span class="nx">dec</span> <span class="o">:=</span> <span class="nx">gob</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buff</span><span class="p">)</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">payload</span><span class="p">)</span>

        <span class="nx">myBestHeight</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">GetBestHeight</span><span class="p">()</span>
        <span class="nx">foreignerBestHeight</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">BestHeight</span>

        <span class="k">if</span> <span class="nx">myBestHeight</span> <span class="p">&lt;</span> <span class="nx">foreignerBestHeight</span> <span class="p">{</span>
                <span class="nf">sendGetBlocks</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">myBestHeight</span> <span class="p">&gt;</span> <span class="nx">foreignerBestHeight</span> <span class="p">{</span>
                <span class="nf">sendVersion</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="nx">bc</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">!</span><span class="nf">nodeIsKnown</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">knownNodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">knownNodes</span><span class="p">,</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>우선 요청을 디코딩하여 페이로드를 가져온다. 이는 모든 핸들러의 공통사항이므로, 앞으로 작성할 코드 스니펫에서 이 코드는 생략할 것이다.</p>
<p>그 다음 노드는 자신의 <strong>BestHeight</strong>와 메시지에서 받은 값을 비교한다. 노드가 가진 블록체인이 더 길면 <strong>version</strong> 메시지로 회신하며, 짧으면 <strong>getblocks</strong> 메시지를 전송한다.</p>
<h2 id="getblocks">getblocks</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">getblocks</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">AddrFrom</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p><strong>getblocks</strong>는 &ldquo;네가 가지고 있는 블록을 보여줘&quot;라는 의미를 지닌다 (비트코인에서는 좀 더 복잡하다). 이는 모든 블록들을 가져오는게 아닌 블록들의 해시 리스트를 요청하는것임에 주의해야한다. 이는 네트워크 로드를 낮추기 위함인데 블록들은 다른 노드들에서도 가져올 수 있으므로, 한 노드에서 수십 기가바이트에 해당하는 블록들을 다운로드할 필요는 없기 때문이다.</p>
<p>커맨드 처리는 아주 쉽다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleGetBlocks</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="nx">blocks</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">GetBlockHashes</span><span class="p">()</span>
        <span class="nf">sendInv</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span> <span class="nx">AddrFrom</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">,</span> <span class="nx">blocks</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>우리의 간소화된 구현에서 이는 <strong>모든 블록의 해시</strong>를 반환한다.</p>
<h2 id="inv">inv</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">inv</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">AddrFrom</span> <span class="kt">string</span>
        <span class="nx">Type</span>     <span class="kt">string</span>
        <span class="nx">Items</span>    <span class="p">[][]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p>비트코인은 <strong>inv</strong>를 사용해 현재 노드가 가진 블록 및 트랜잭션을 다른 노드에 표시한다. 다시 말하지만, 이는 전체 블록과 트랜잭션이 아니라 그저 블록과 트랜잭션의 해시값만 포함하고있다.</p>
<p><strong>inv</strong> 처리는 조금 복잡하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleInv</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received inventory with %d %s\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">Items</span><span class="p">),</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s">&#34;block&#34;</span> <span class="p">{</span>
                <span class="nx">blocksInTransit</span> <span class="p">=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Items</span>

                <span class="nx">blockHash</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nf">sendGetData</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">,</span> <span class="nx">blockHash</span><span class="p">)</span>

                <span class="nx">newInTransit</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{}</span>
                <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blocksInTransit</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">blockHash</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nx">newInTransit</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newInTransit</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
                        <span class="p">}</span>
                <span class="p">}</span>
                <span class="nx">blocksInTransit</span> <span class="p">=</span> <span class="nx">newInTransit</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s">&#34;tx&#34;</span> <span class="p">{</span>
                <span class="nx">txID</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">mempool</span><span class="p">[</span><span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">txID</span><span class="p">)].</span><span class="nx">ID</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nf">sendGetData</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="s">&#34;tx&#34;</span><span class="p">,</span> <span class="nx">txID</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>블록 해시값들을 전달받으면 다운로드한 블록을 추적하기 위해 <strong>blocksInTransit</strong> 변수에 저장한다. 이렇게 하면 다른 노드에서 블록을 다운로드 할 수 있다. 블록을 전송 상태로 전환한 직후에 <strong>inv</strong> 메시지를 보낸 노드에게 <strong>getdata</strong> 커맨드를 전송하고 <strong>blockInTransit</strong>을 갱신한다. 실제 P2P 네트워크에서는 메시지를 보낸 노드만이 아니라 서로 다른 노드에서 블록을 전송하려고 한다.</p>
<p>우리의 구현에서는 <strong>inv</strong>에 다중 해시를 전송하지 않는다. 이게 **payload.Type == &ldquo;tx&rdquo;**에서 첫 해시만 취해 검사하는 이유이다. mempool에 해시가 존재하는지 확인한 뒤, 없으면 <strong>getdata</strong> 메시지를 전송한다.</p>
<h2 id="getdata">getdata</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">getdata</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">AddrFrom</span> <span class="kt">string</span>
        <span class="nx">Type</span>     <span class="kt">string</span>
        <span class="nx">ID</span>       <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p><strong>getdata</strong>는 특정 블록 및 트랜잭션에 대한 요청이며, 단 하나의 블록 및 트랜잭션의 ID만을 포함할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleGetData</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s">&#34;block&#34;</span> <span class="p">{</span>
                <span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">GetBlock</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
                <span class="nf">sendBlock</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">block</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="s">&#34;tx&#34;</span> <span class="p">{</span>
                <span class="nx">txID</span> <span class="o">:=</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
                <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">mempool</span><span class="p">[</span><span class="nx">txID</span><span class="p">]</span>
                <span class="nf">sendTx</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">tx</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>요청이 블록이면 블록을, 트랜잭션이면 트랜잭션을 반환한다. 노드가 블록 또는 트랜잭션을 가지고 있는지 확인하는 과정이 없는데 이는 결함이다.</p>
<h2 id="block과-tx">block과 tx</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">block</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">AddrFrom</span> <span class="kt">string</span>
        <span class="nx">Block</span>    <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">tx</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">AddrFrom</span>    <span class="kt">string</span>
        <span class="nx">Transaction</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p>실제로 데이터를 전달하는 메시지 구조체이다.</p>
<p><strong>block</strong> 메시지 처리는 쉽다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleBlock</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>

        <span class="nx">blockData</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Block</span>
        <span class="nx">block</span> <span class="o">:=</span> <span class="nf">DeserializeBlock</span><span class="p">(</span><span class="nx">blockData</span><span class="p">)</span>

        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Received a new block!&#34;</span><span class="p">)</span>
        <span class="nx">bc</span><span class="p">.</span><span class="nf">AddBlock</span><span class="p">(</span><span class="nx">block</span><span class="p">)</span>

        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Added block %x\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Hash</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blocksInTransit</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">blockHash</span> <span class="o">:=</span> <span class="nx">blocksInTransit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nf">sendGetData</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">,</span> <span class="nx">blockHash</span><span class="p">)</span>
                <span class="nx">blocksInTransit</span> <span class="p">=</span> <span class="nx">blocksInTransit</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">UTXOSet</span> <span class="o">:=</span> <span class="nx">UTXOSet</span><span class="p">{</span><span class="nx">bc</span><span class="p">}</span>
                <span class="nx">UTXSOSet</span><span class="p">.</span><span class="nf">Reindex</span><span class="p">()</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>새로운 블록을 받으면 자신의 블록체인에 추가한다. 다운로드할 블록이 더 있다면 이전 블록을 다운로드 받은 동일한 노드에게 블록을 요청한다. 블록이 모두 다운로드되면 UTXO 집합의 재색인이 이루어진다.</p>
<blockquote>
<p>TODO: 무조건 신뢰하는 대신, 블록체인에 추가하기 전에 수신하는 모든 블록의 유효성을 검사해야한다.</p>
<p>TODO: 블록체인이 크기 때문에 UTXOSet.Reindex() 대신 UTXOSet.Update(block)을 사용해야한다. 전체 UTXO 집합을 재색인하는데에는 아주 많은 시간이 소요된다.</p>
</blockquote>
<p><strong>tx</strong> 메시지 처리는 조금 복잡하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleTx</span><span class="p">(</span><span class="nx">request</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bc</span> <span class="o">*</span><span class="nx">Blockchain</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">txData</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">Transaction</span>
    <span class="nx">tx</span> <span class="o">:=</span> <span class="nf">DeserializeTransaction</span><span class="p">(</span><span class="nx">txData</span><span class="p">)</span>
    <span class="nx">mempool</span><span class="p">[</span><span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">ID</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">tx</span>

    <span class="k">if</span> <span class="nx">nodeAddress</span> <span class="o">==</span> <span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">knownNodes</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">nodeAddress</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">AddrFrom</span> <span class="p">{</span>
                <span class="nf">sendInv</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s">&#34;tx&#34;</span><span class="p">,</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">tx</span><span class="p">.</span><span class="nx">ID</span><span class="p">})</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mempool</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">miningAddress</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">MineTransactions</span><span class="p">:</span>
            <span class="kd">var</span> <span class="nx">txs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Transaction</span>

            <span class="k">for</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mempool</span> <span class="p">{</span>
                <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">mempool</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">VerifyTransaction</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tx</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">tx</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">txs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;All transactions are invalid! Waiting for new ones...&#34;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>

            <span class="nx">cbTx</span> <span class="o">:=</span> <span class="nf">NewCoinbaseTX</span><span class="p">(</span><span class="nx">miningAddress</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
            <span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txs</span><span class="p">,</span> <span class="nx">cbTx</span><span class="p">)</span>

            <span class="nx">newBlock</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">MineBlock</span><span class="p">(</span><span class="nx">txs</span><span class="p">)</span>
            <span class="nx">UTXOSet</span> <span class="o">:=</span> <span class="nx">UTXOSet</span><span class="p">{</span><span class="nx">bc</span><span class="p">}</span>
            <span class="nx">UTXOSet</span><span class="p">.</span><span class="nf">Reindex</span><span class="p">()</span>

            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;New block is mined!&#34;</span><span class="p">)</span>

            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">txs</span> <span class="p">{</span>
                <span class="nx">txID</span> <span class="o">:=</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
                <span class="nb">delete</span><span class="p">(</span><span class="nx">mempool</span><span class="p">,</span> <span class="nx">txID</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">knownNodes</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">nodeAddress</span> <span class="p">{</span>
                    <span class="nf">sendInv</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">,</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mempool</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">goto</span> <span class="nx">MineTransactions</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>처음에 할 일은 새로운 트랜잭션을 mempool에 추가하는 것이다 (다시 말하지만, 트랜잭션은 mempool에 추가되기 전에 반드시 검증되어야한다). 다음 코드를 살펴보자.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">nodeAddress</span> <span class="o">==</span> <span class="nx">knownNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">knownNodes</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">nodeAddress</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">AddFrom</span> <span class="p">{</span>
            <span class="nf">sendInv</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s">&#34;tx&#34;</span><span class="p">,</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">tx</span><span class="p">.</span><span class="nx">ID</span><span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>현재 노드가 중앙 노드인지를 확인한다. 우리의 구현체에서 중앙 노드는 블록을 채굴하지 않는다. 대신 새로운 트랜잭션을 네트워크상의 다른 노드들에게 전달해준다.</p>
<p>그 다음 코드는 채굴자 노드에만 해당한다. 각 부분별로 살펴보자.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mempool</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">miningAddress</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{}</span>
</code></pre></div><p><strong>miningAddress</strong>은 채굴자 노드에만 있다. 현재 (채굴자) 노드의 mempool에 두 개 이상의 트랜잭션이 있을때 채굴을 시작한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mempool</span> <span class="p">{</span>
    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">mempool</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">VerifyTransaction</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tx</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">tx</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">txs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;All transactions are invalid! Waiting for new ones...&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>먼저 mempool의 모든 트랜잭션이 검증된다. 유효하지 않은 트랜잭션은 무시되며, 유효한 트랜잭션이 없는 경우 채굴은 중단된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">cbTx</span> <span class="o">:=</span> <span class="nf">NewCoinbaseTX</span><span class="p">(</span><span class="nx">miningAddress</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txs</span><span class="p">,</span> <span class="nx">cbTx</span><span class="p">)</span>

<span class="nx">newBlock</span> <span class="o">:=</span> <span class="nx">bc</span><span class="p">.</span><span class="nf">MineBlock</span><span class="p">(</span><span class="nx">txs</span><span class="p">)</span>
<span class="nx">UTXOSet</span> <span class="o">:=</span> <span class="nx">UTXOSet</span><span class="p">{</span><span class="nx">bc</span><span class="p">}</span>
<span class="nx">UTXOSet</span><span class="p">.</span><span class="nf">Reindex</span><span class="p">()</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;New block is mined!&#34;</span><span class="p">)</span>
</code></pre></div><p>검증된 트랜잭션은 보상을 가진 코인베이스 트랜잭션과 함께 블록에 추가된다. 블록 채굴이 끝나면 UTXO 집합은 재색인된다.</p>
<blockquote>
<p>TODO: 마찬가지로, UTXOSet.Reindex 대신 UTXOSet.Update를 사용하는게 더 좋다.</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">txs</span> <span class="p">{</span>
    <span class="nx">txID</span> <span class="o">:=</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
    <span class="nb">delete</span><span class="p">(</span><span class="nx">mempool</span><span class="p">,</span> <span class="nx">txID</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">knownNodes</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="nx">nodeAddress</span> <span class="p">{</span>
        <span class="nf">sendInv</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">,</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">newBlock</span><span class="p">.</span><span class="nx">Hash</span><span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mempool</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">goto</span> <span class="nx">MineTransactions</span>
<span class="p">}</span>
</code></pre></div><p>트랜잭션은 채굴된 후 mempool에서 제거된다. 현재 노드가 알고있는 모든 노드들은 새로운 블록 해시가 담긴 <strong>inv</strong> 메시지를 받는다. 이 노드들은 메시지를 처리한 후에 블록을 요청할 수 있다.</p>
<h1 id="결과">결과</h1>
<p>앞에서 정의했던 시나리오를 시연해보자.</p>
<p>먼저 첫 번째 터미널에서 <strong>NODE_ID</strong>를 3000으로 설정 (<strong>export NODE_ID=3000</strong>)한다. 커맨드를 실행하는 노드를 알 수 있도록 설명하기 전마다 <strong>NODE 3000</strong>이나 <strong>NODE 3001</strong>과 같이 표시를 해두겠다.</p>
<p><strong>NODE 3000</strong></p>
<p>지갑과 블록체인을 생성하자.</p>
<pre><code>$ blockchain_go createblockchain -address CENTRAL_NODE
</code></pre><p>(간결한 설명을 위해 가짜 주소를 사용하겠다)</p>
<p>커맨드 실행이 끝나면 블록체인은 하나의 제네시스 블록을 갖게될 것이다. 그 다음 다른 노드에서 사용할 수 있도록 블록을 저장해야한다. 제네시스 블록은 블록체인의 식별자로 사용된다 (비트코인의 제네시스 블록은 하드코딩 되어있다).</p>
<pre><code>$ cp blockchain_3000.db blockchain_genesis.db
</code></pre><p><strong>NODE 3001</strong></p>
<p>다음으로, 새 터미널을 열어 노드 ID를 3001로 설정한다. 이는 지갑 노드이다. <strong>blockchain_go createwallet</strong>으로 몇 개의 주소를 생성해 각 주소를 <strong>WALLET_1</strong>, <strong>WALLET_2</strong>, <strong>WALLET_3</strong>라고 부르자.</p>
<p><strong>NODE 3000</strong></p>
<p>지갑 주소로 코인을 전송해보자.</p>
<pre><code>$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount 10 -mine
$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount 10 -mine
</code></pre><p><strong>-mine</strong> 플래그는 블록이 전송 노드에 의해 즉시 채굴됨을 의미한다. 초기에는 네트워크에 채굴자 노드가 없기 때문에 이 플래그를 사용해야한다.
이제 노드를 실행해보자.</p>
<pre><code>$ blockchain_go startnode
</code></pre><p>이 노드는 반드시 시나리오가 끝날때까지 계속 실행되어야 한다.</p>
<p><strong>NODE 3001</strong></p>
<p>위에서 저장한 제네시스 블록으로 노드의 블록체인을 시작한다.</p>
<pre><code>$ cp blockchain_genesis.db blockchain_3001.db
</code></pre><p>노드를 실행하자.</p>
<pre><code>$ blockchain_go startnode
</code></pre><p>이 노드는 중앙 노드로부터 모든 블록을 다운로드 받는다. 잘 동작하는지 확인하기 위해 노드를 중지하고 잔고를 확인해보자.</p>
<pre><code>$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 10

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 10
</code></pre><p>3001 노드는 이제 자체 블록체인을 가지고 있기 때문에 <strong>CENTRAL_NODE</strong> 주소의 잔고도 확인할 수 있다.</p>
<pre><code>$ blockchain_go getbalance -address CENTRAL_NODE
Balance of 'CENTRAL_NODE': 10
</code></pre><p><strong>NODE 3002</strong></p>
<p>새 터미널을 열어 노드 ID를 3002로 설정하고 지갑을 생성한다. 이는 채굴자 노드이다. 블록체인을 초기화하자.</p>
<pre><code>$ cp blockchain_genesis.db blockchain_3002.db
</code></pre><p>노드를 실행하자.</p>
<pre><code>$ blockchain_go startnode -miner MINER_WALLET
</code></pre><p><strong>NODE 3001</strong></p>
<p>코인을 전송해보자.</p>
<pre><code>$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount 1
$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount 1
</code></pre><p><strong>NODE 3002</strong></p>
<p>채굴자 노드로 전환하면 새로운 블록을 채굴하는걸 볼 수 있을 것이다. 그리고 중앙 노드의 출력을 확인해보아라.</p>
<p><strong>NODE 3001</strong></p>
<p>지갑 노드로 전환하고 노드를 실행하자.</p>
<pre><code>$ blockchain_go startnode
</code></pre><p>노드를 실행하면 새로 채굴된 블록을 다운로드할 것이다.</p>
<p>노드를 중지하고 잔고를 확인해보자.</p>
<pre><code>$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 9

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 9

$ blockchain_go getbalance -address WALLET_3
Balance of 'WALLET_3': 1

$ blockchain_go getbalance -address WALLET_4
Balance of 'WALLET_4': 1

$ blockchain_go getbalance -address MINER_WALLET
Balance of 'MINER_WALLET': 10
</code></pre><p>다 되었다!</p>
<h1 id="결론">결론</h1>
<p>드디어 시리즈가 끝났다. P2P 네트워크의 실제 프로토타입을 구현하는 포스트를 더 작성하고 싶었지만 시간이 부족했다. 이 시리즈로 비트코인 기술에 대한 질문에 답을 얻고 새로운 질문을 제기하여 여러분 스스로가 답을 할 수 있기를 바란다. 비트코인 기술에는 더 많은 흥미로운 주제들이 숨겨져 있다! 행운을 빈다!</p>
<p>P.S <a href="https://en.bitcoin.it/wiki/Protocol_documentation">비트코인 네트워크 프로토콜</a>에 설명되어 있는 <strong>addr</strong> 메시지를 구현함으로써 네트워크를 개선해볼 수 있다. 이는 노드들이 서로를 탐색할 수 있도록 만들어주기 때문에 아주 중요하다. 필자 또한 구현중이지만 아직 완성되진 않았다.</p>
<p>링크:</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_7">소스 코드</a></li>
<li><a href="https://en.bitcoin.it/wiki/Network">비트코인 네트워크</a></li>
</ol>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2fbuilding-blockchain-in-go-part-7%2f - %5bGo%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%5d%20Part%207%3a%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
            <div class="adsense">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                
                <ins class="adsbygoogle"
                    style="display:block"
                    data-ad-client="ca-pub-9436560391944255"
                    data-ad-slot="5717491307"
                    data-ad-format="auto"
                    data-full-width-responsive="true"></ins>
                <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>
            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/go-modules-private-repo">Go 프라이빗 모듈 가져오기<aside class="dates">Apr 18 2020</aside></a>
        </li>
    
        <li>
            <a href="/debugging-containerized-go-app">컨테이너 내부 Go 애플리케이션 디버깅하기<aside class="dates">Feb 13 2020</aside></a>
        </li>
    
        <li>
            <a href="/debug-memory-leak-with-node-heapdump">푸시 데몬 메모리 누수 디버깅하기<aside class="dates">Nov 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/scheduling-cron-job-in-seconds-interval">Cron에서 초단위로 스케줄링하기<aside class="dates">Aug 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/dynamodb-batch-retry-with-exponential-backoff">DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)<aside class="dates">Jun 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/redis-migration">IDC에서 AWS로 Redis 데이터 이전하기<aside class="dates">Feb 1 2019</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-3">[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI<aside class="dates">May 22 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-84081627-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
