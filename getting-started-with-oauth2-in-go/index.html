<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">
		
		

		<meta name="generator" content="Hugo 0.39" />
		<title>Go에서 OAuth2 인증하기 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Go에서 OAuth2 인증하기
                    </h1>
                    <h2 class="headline">
                    Feb 1, 2018 00:00
                    · 3702 words
                    · 8 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/oauth2">oauth2</a>
                          
                              <a href="https://mingrammer.com/tags/tutorial">tutorial</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#oauth2-플로우">OAuth2 플로우</a></li>
<li><a href="#준비사항">준비사항</a>
<ul>
<li><a href="#의존성-설치">의존성 설치</a></li>
<li><a href="#키값-발급">키값 발급</a></li>
<li><a href="#콜백-url-지정">콜백 URL 지정</a></li>
</ul></li>
<li><a href="#예제용-애플리케이션-구성">예제용 애플리케이션 구성</a></li>
<li><a href="#인증-정보-설정">인증 정보 설정</a></li>
<li><a href="#인증-처리">인증 처리</a></li>
<li><a href="#전체-코드">전체 코드</a>
<ul>
<li><a href="#auth-go">auth.go</a></li>
<li><a href="#main-go">main.go</a></li>
</ul></li>
<li><a href="#마무리">마무리</a></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<p><a href="https://oauth.net/2/">OAuth2</a>란, 일종의 인증 프로토콜로써 소셜 인증을 통한 로그인 및 권한 제어를 위해 사용된다. Google, Twitter, Github 등 대부분의 소셜 인증 기능을 지닌 프로바이더들은 표준 인증 방식으로 OAuth2를 채택하고 있으며 그에 따른 OAuth2 API들을 제공하고 있다.</p>

<p>이번 포스팅에서는 Go에서 OAuth2 인증을 처리하는 방법을 다루고자 한다.</p>

<p>Go는 다양한 기능의 내장 라이브러리와 공식 서드파티 라이브러리의 지원이 꽤 잘되어있는 편인데 OAuth2 또한 Go 공식 서드파티 라이브러리가 이미 존재한다. 따라서 별도의 비공식 서드파티 라이브러리를 사용할 필요가 없으며 사실상 이미 준비는 다 되어있다고 보면된다.</p>

<p>이 포스팅에서는 대표적인 OAuth2 프로바이더인 Google을 기준으로 설명을 진행할 것이다. 이 외의 프로바이더에 대해서도 OAuth2 동작방식은 동일하니 사용하려는 프로바이더가 다를 경우엔 일부 설정 및 인증 정보만 바꿔주면 된다. (이 부분은 <strong>인증 정보 설정</strong>을 참고)</p>

<p>우선 코드를 살펴보기 전에 OAuth2의 인증 플로우부터 살펴보도록 하겠다.</p>

<p><br></p>

<h1 id="oauth2-플로우">OAuth2 플로우</h1>

<p>OAuth2의 추상적인 플로우를 살펴보면 다음과 같다.</p>

<p><img src="../images/2018-02-01-oauth2-abstract-flow.png" alt="OAuth2 Absctract Flow" /></p>

<p><center><em>출처: <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">Digital Ocean</a></em></center></p>

<ol>
<li>유저가 로그인 페이지에 접속을 한다.</li>
<li>로그인 페이지 접속시 유저를 식별하기 위해 생성한 랜덤한 <code>state</code>값을 사용해 구글 로그인 링크를 생성한다.</li>
<li>유저는 반환된 구글 로그인 링크를 클릭해 소셜 로그인을 진행한다.</li>
<li>소셜 로그인 후에 구글 인증 서버는 토큰 발급을 위한 임시 <code>code</code> 값과 이전에 전송했던 <code>state</code> 값을 미리 등록했던 콜백 URL에 붙여 리다이렉트 한다.</li>
<li>콜백 URL로 호출되는 인증 처리 핸들러에서는 <code>state</code> 값이 이전값과 같은지 확인한 뒤, 받은 <code>code</code> 값을 사용해 실제 리소스 사용 권한이 담긴 <strong>엑세스 토큰</strong> 을 발급 받기 위해 구글 인증 서버로 요청을 보낸다.</li>
<li>인증 서버로부터 <strong>엑세스 토큰</strong>을 받으면 필요한 리소스를 요청할 수 있게 된다.</li>
</ol>

<p><br></p>

<h1 id="준비사항">준비사항</h1>

<p>코드를 작성하기 전에 두 가지 준비해야할 사항이 있다. 그 중 하나는 인증 처리를 위한 의존 라이브러리 설치이며 나머지 하나는 사용할 프로바이더의 OAuth2 API를 사용하기 위한 키값 발급 및 콜백 URL 지정이다.</p>

<h2 id="의존성-설치">의존성 설치</h2>

<pre><code class="language-bash">go get golang.org/x/oauth2

# (선택사항) 세션 관리는 원하는 형태로 해도 되며, 여기선 gorilla의 sessions를 사용하여 세션을 관리
go get github.com/gorilla/sessions
</code></pre>

<h2 id="키값-발급">키값 발급</h2>

<p>OAuth2 API를 사용하기 위해선 API를 제공하는 프로바이더에 애플리케이션을 등록한 뒤 OAuth2 API 사용 권한 인증을 위한 키값들을 발급받아야한다. 구글의 경우 <a href="https://console.developers.google.com">Google API Console</a>에서 애플리케이션을 등록할 수 있다. 등록 후, <strong>사용자 인증 정보</strong> 페이지에 접속하면 <strong>사용자 인증 정보 만들기</strong>의 <strong>OAuth 클라이언트 ID</strong> 메뉴를 통해 클라이언트 ID와 시크릿 키값을 발급 받을 수 있다.</p>

<p>이렇게 발급받은 클라이언트 ID와 시크릿 키값은 <strong>인증 정보 설정</strong>에서 사용할 것이다.</p>

<h2 id="콜백-url-지정">콜백 URL 지정</h2>

<p>사용자가 프로바이더 인증 서버에 권한을 요청하면 인증 서버는 미리 등록된 콜백 URL을 통해 토큰 발급시 사용될 임시 코드값을 클라이언트에 전달하게 된다. (위 그림으로 보면 <strong>3</strong>번에서 이 과정이 이루어진다) 따라서 우리는 이 때 사용할 콜백 URL을 좀 전에 만든 애플리케이션에 미리 등록해야한다. 키값을 발급했던 페이지에 있는 <strong>승인된 리디렉션 URI</strong> 칸에 콜백 URL을 지정할 수 있다. 여기에서는 <code>http://127.0.0.1:1333/auth/callback</code>로 지정하도록 하자.</p>

<p>준비는 다 끝났다. 그럼 이제 OAuth2 인증을 실제로 구현해보도록 하자.</p>

<p><br></p>

<h1 id="예제용-애플리케이션-구성">예제용 애플리케이션 구성</h1>

<p>이 포스팅의 목적은 하나의 완전한 애플리케이션의 구현이 아닌 OAuth2 인증에 초점이 맞춰져 있기 때문에 아주 단순한 구조의 예제용 애플리케이션을 구성해보도록 하겠다.</p>

<p>예제로 사용할 애플리케이션 구조는 다음과 같다.</p>

<pre><code>├─ auth.go
├─ auth.html
├─ main.go
└─ main.html
</code></pre>

<ul>
<li><strong>auth.go</strong> : 인증 관련 정보 설정</li>
<li><strong>auth.html</strong> : 인증 시작 페이지</li>
<li><strong>main.go</strong> : 핸들러 관리</li>
<li><strong>main.html</strong> : 메인 페이지</li>
</ul>

<p>구조는 매우 단순하며 상세한 인증 플로우는 잠시 후 살펴보도록 하겠다. <strong>main.html</strong>과 <strong>auth.html</strong>는 단순히 인증 링크 접속을 위한 페이지라 아주 단순하다.</p>

<pre><code class="language-html">&lt;!-- main.html --&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/auth&quot;&gt;Sign In&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-html">&lt;!-- auth.html --&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;!-- href는 로그인 핸들러로부터 반환 받은 Google 로그인 링크가 담긴다 --&gt;
    &lt;a href=&quot;{{ . }}&quot;&gt;Google Login&lt;/a&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>main.go</strong>는 페이지 렌더링과 인증을 처리하는 핸들러를 관리한다.</p>

<pre><code class="language-go">func main() {
    http.HandleFunc(&quot;/&quot;, RenderMainView)
    http.HandleFunc(&quot;/auth&quot;, RenderAuthView)
    http.HandleFunc(&quot;/auth/callback&quot;, Authenticate)

    log.Fatal(http.ListenAndServe(&quot;:1333&quot;, nil))
}

// 메인 뷰 핸들러
func RenderMainView(w http.ResponseWriter, r *http.Request) {
}

// 랜덤 state 값을 가진 구글 로그인 링크를 렌더링 해주는 뷰 핸들러
// 랜덤 state는 유저를 식별하는 용도로 사용된다
func RenderAuthView(w http.ResponseWriter, r *http.Request) {
}

// Google OAuth 인증 콜백 핸들러
func Authenticate(w http.ResponseWriter, r *http.Request) {
}
</code></pre>

<p><br></p>

<h1 id="인증-정보-설정">인증 정보 설정</h1>

<p><code>auth.go</code>는 위에서 살펴봤던 OAuth2 인증을 위한 설정값과 인증에 필요한 데이터들을 독립적으로 관리하기위한 용도이다.</p>

<pre><code class="language-go">// auth.go
const (
    CallBackURL = &quot;http://localhost:1333/auth/callback&quot;
  
    // 인증 후 유저 정보를 가져오기 위한 API
    UserInfoAPIEndpoint = &quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;
  
    // 인증 권한 범위. 여기에서는 프로필 정보 권한만 사용
    ScopeEmail          = &quot;https://www.googleapis.com/auth/userinfo.email&quot;
    ScopeProfile        = &quot;https://www.googleapis.com/auth/userinfo.profile&quot;
)
</code></pre>

<p><code>CallBackURL</code>은 인증 서버가 권한 요청을 받은 후 리다이렉트할 URL이며, 프로바이더에 등록한 애플리케이션에서 지정한 콜백 URL과 일치해야한다.</p>

<p>아래 나머지 URL들은 인증 후 발급된 토큰으로 리소스를 요청할 때 사용하는 URL들이다. (여기선, 인증 후 유저 정보를 가져오기 위함)</p>

<pre><code class="language-go">// auth.go
var OAuthConf *oauth2.Config

func init() {
    OAuthConf = &amp;oauth2.Config{
        ClientID:     &quot;google client id&quot;,
        ClientSecret: &quot;google client secret&quot;,
        RedirectURL:  CallBackURL,
        Scopes:       []string{ScopeEmail, ScopeProfile},
        Endpoint:     google.Endpoint,
    }
}

// state 값과 함께 Google 로그인 링크 생성
func GetLoginURL(state string) string {
    return OAuthConf.AuthCodeURL(state)
}

// 랜덤 state 생성기
func RandToken() string {
    b := make([]byte, 32)
    rand.Read(b)
    return base64.StdEncoding.EncodeToString(b)
}
</code></pre>

<p><strong>oauth2.Config</strong>는 인증 처리를 위한 설정값들을 관리하는 구조체이다. 클라이언트 ID, 시크릿 키값 그리고 콜백 URL등을  지정할 수 있다. 위에서 발급받은 키값들로 설정하면된다. 더 좋은 방법은 키값을 코드에 바로 넣지 않고 환경 변수로 설정해 <code>os.GetEnv()</code>로 가져오는 방법이 있다. 실제 프로덕션에서 사용한다면 이 방법을 추천한다.</p>

<p>인증 처리에 필요한 설정값들을 모두 가지고 있어, 사실상 OAuth2 인증 처리를 위한 URL 생성, 토큰 교환과 같은 대부분의 기능들이 이 구조체의 메서드들로 이루어진다.</p>

<p><strong>GetLoginURL</strong>은 <code>state</code> 값을 사용하여 생성한 구글 로그인 링크를 반환한다. 이 때, 이 로그인 링크에는 <code>OAuthConf</code>에서 설정한 <code>RedirectURL</code>이 따라 붙는다.</p>

<p><br></p>

<h1 id="인증-처리">인증 처리</h1>

<p>인증에 필요한 정보들을 다 설정했으니 이제 실제 인증 처리 과정을 살펴보자.</p>

<p>우선 Google 인증을 하기 전에 로그인 페이지에 접속하는 과정부터 살펴보자.</p>

<pre><code class="language-go">// main.go
func RenderAuthView(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, &quot;session&quot;)
    session.Options = &amp;sessions.Options{
        Path:   &quot;/auth&quot;,
        MaxAge: 300,
     }
    state := RandToken()
    session.Values[&quot;state&quot;] = state
    session.Save(r, w)
    RenderTemplate(w, &quot;auth.html&quot;, GetLoginURL(state))
}
</code></pre>

<p>로그인 페이지에 접속하는 순간 <code>state</code> 값을 생성해 세션에 저장한 후, 이를 사용해 생성한 구글 로그인 링크를 반환한다. 세션에 저장한 <code>state</code> 값은 추후 콜백 인증 핸들러에서 <code>state</code> 값을 비교하기 위해 사용된다.</p>

<p>이후 유저는 <strong>auth.html</strong>에 렌더링된 구글 로그인 링크를 통해 구글 로그인을 시도할 것이다. 구글 로그인을 시도하면 위에서 생성된 <code>state</code> 값 및 <code>RedirectURL</code>과 함께 인증 서버에 권한 요청을 하게 된다. 인증 서버는 요청을 받고 <code>code</code> 값을 생성한 뒤 이 값을 <code>RedirectURL</code>에 붙여 리다이렉트를 한다.</p>

<p><code>RedirectURL</code>인 <code>http://127.0.0.1:1333/auth/callback</code>로 리다이렉트가 되면 <code>Authenticate</code> 핸들러가 호출되고 토큰 인증 작업이 시작된다.</p>

<pre><code class="language-go">// main.go
func Authenticate(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, &quot;session&quot;)
    state := session.Values[&quot;state&quot;]

    delete(session.Values, &quot;state&quot;)
    session.Save(r, w)

    if state != r.FormValue(&quot;state&quot;) {
        http.Error(w, &quot;Invalid session state&quot;, http.StatusUnauthorized)
        return
    }
  
    ...
}
</code></pre>

<p>콜백 핸들러가 호출되면 제일 먼저 <code>state</code> 값이 유효한지 체크한다. 세션에 저장되어 있는 <code>state</code> 값과 비교를 진행하며 한 번 사용된 <code>state</code>는 세션에서 삭제한다.</p>

<pre><code class="language-go">// main.go
func Authenticate(w http.ResponseWriter, r *http.Request) {
    ...
  
    token, err := OAuthConf.Exchange(oauth2.NoContext, r.FormValue(&quot;code&quot;))
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
  
    ...
}
</code></pre>

<p><code>state</code> 값이 유효하면 이제 전달받은 <code>code</code>를 사용해 인증 서버에 <strong>엑세스 토큰</strong>을 요청한다. <code>code</code> 값이 유효하다면 토큰을 정상적으로 받을 수 있다.</p>

<pre><code class="language-go">// main.go
func Authenticate(w http.ResponseWriter, r *http.Request) {
    ...
  
    client := OAuthConf.Client(oauth2.NoContext, token)
    // UserInfoAPIEndpoint는 유저 정보 API URL을 담고 있음
    userInfoResp, err := client.Get(UserInfoAPIEndpoint)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    defer userInfoResp.Body.Close()
    userInfo, err := ioutil.ReadAll(userInfoResp.Body)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    var authUser User
    json.Unmarshal(userInfo, &amp;authUser)
  
    ...
}
</code></pre>

<p>토큰을 받은 클라이언트는 이제 이 토큰을 가지고 유저 정보 리소스를 요청할 수 있다. 이 때, 요청 가능 데이터에 대한 범위는 아까 <strong>인증 정보 설정</strong>에서 살펴본 <code>OAuthConf</code>의 <code>Scopes</code>에서 지정한 권한 범위와 일치한다.</p>

<p>요청 데이터가 권한 범위 안에 속한다면 요청 데이터를 정상적으로 받아올 것이다.</p>

<pre><code class="language-go">// main.go
func Authenticate(w http.ResponseWriter, r *http.Request) {
    ...

    session.Options = &amp;sessions.Options{
        Path:   &quot;/&quot;,
        MaxAge: 86400,
    }
    session.Values[&quot;user&quot;] = authUser.Email
    session.Values[&quot;username&quot;] = authUser.Name
    session.Save(r, w)

    http.Redirect(w, r, &quot;/&quot;, http.StatusFound)
}
</code></pre>

<p>마지막으로 필수는 아니지만 받아온 데이터를 로그인 유지등의 목적으로 계속 사용하고자 한다면 세션에 넣어 관리할 수도 있다.</p>

<p><br></p>

<h1 id="전체-코드">전체 코드</h1>

<p>예제 테스트를 해볼 수 있도록 전체 코드를 공개하겠다. <strong>auth.html</strong>과 <strong>main.html</strong> 코드는 위에서 볼 수 있다.</p>

<h2 id="auth-go">auth.go</h2>

<pre><code class="language-go">package main

import (
    &quot;crypto/rand&quot;
    &quot;encoding/base64&quot;

    &quot;golang.org/x/oauth2&quot;
    &quot;golang.org/x/oauth2/google&quot;
)

type User struct {
    Name  string `json:&quot;name&quot;`
    Email string `json:&quot;email&quot;`
}

const (
    CallBackURL = &quot;http://localhost:1333/auth/callback&quot;
  
    UserInfoAPIEndpoint = &quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;
    ScopeEmail          = &quot;https://www.googleapis.com/auth/userinfo.email&quot;
    ScopeProfile        = &quot;https://www.googleapis.com/auth/userinfo.profile&quot;
)

var OAuthConf *oauth2.Config

func init() {
    OAuthConf = &amp;oauth2.Config{
        ClientID:     &quot;google client id&quot;,
        ClientSecret: &quot;google client secret&quot;,
        RedirectURL:  CallBackURL,
        Scopes:       []string{ScopeEmail, ScopeProfile},
        Endpoint:     google.Endpoint,
    }
}

func GetLoginURL(state string) string {
    return OAuthConf.AuthCodeURL(state)
}

func RandToken() string {
    b := make([]byte, 32)
    rand.Read(b)
    return base64.StdEncoding.EncodeToString(b)
}
</code></pre>

<h2 id="main-go">main.go</h2>

<pre><code class="language-go">package main

import (
    &quot;encoding/json&quot;
    &quot;html/template&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/gorilla/sessions&quot;
    &quot;golang.org/x/oauth2&quot;
)

var store = sessions.NewCookieStore([]byte(&quot;secret&quot;))

func main() {
    http.HandleFunc(&quot;/&quot;, RenderMainView)
    http.HandleFunc(&quot;/auth&quot;, RenderAuthView)
    http.HandleFunc(&quot;/auth/callback&quot;, Authenticate)

    log.Fatal(http.ListenAndServe(&quot;:1333&quot;, nil))
}

func RenderTemplate(w http.ResponseWriter, name string, data interface{}) {
    tmpl, _ := template.ParseFiles(name)
    tmpl.Execute(w, data)
}

func RenderMainView(w http.ResponseWriter, r *http.Request) {
    RenderTemplate(w, &quot;main.html&quot;, nil)
}

func RenderAuthView(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, &quot;session&quot;)
    session.Options = &amp;sessions.Options{
        Path:   &quot;/auth&quot;,
        MaxAge: 300,
	}
    state := RandToken()
    session.Values[&quot;state&quot;] = state
    session.Save(r, w)
    RenderTemplate(w, &quot;auth.html&quot;, GetLoginURL(state))
}

func Authenticate(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, &quot;session&quot;)
    state := session.Values[&quot;state&quot;]

    delete(session.Values, &quot;state&quot;)
    session.Save(r, w)

    if state != r.FormValue(&quot;state&quot;) {
        http.Error(w, &quot;Invalid session state&quot;, http.StatusUnauthorized)
        return
    }

    token, err := OAuthConf.Exchange(oauth2.NoContext, r.FormValue(&quot;code&quot;))
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    client := OAuthConf.Client(oauth2.NoContext, token)
    userInfoResp, err := client.Get(UserInfoAPIEndpoint)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    defer userInfoResp.Body.Close()
    userInfo, err := ioutil.ReadAll(userInfoResp.Body)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    var authUser User
    json.Unmarshal(userInfo, &amp;authUser)

    session.Options = &amp;sessions.Options{
        Path:   &quot;/&quot;,
        MaxAge: 86400,
    }
    session.Values[&quot;user&quot;] = authUser.Email
    session.Values[&quot;username&quot;] = authUser.Name
    session.Save(r, w)

    http.Redirect(w, r, &quot;/&quot;, http.StatusFound)
}
</code></pre>

<p><br></p>

<h1 id="마무리">마무리</h1>

<p>이제까지 아주 보편적으로 널리 사용되고 있는 OAuth2 인증을 Go로 구현하는 방법을 살펴보았다. OAuth2에 친숙하지 않은 사람이라면 다소 복잡해 보일 수 있지만 OAuth2 플로우만 잘 이해한다면 코드 또한 쉽게 이해할 수 있을 것이다.</p>

<p>예제 코드 수준이라 코드 정리가 덜 되었지만 실제 프로덕션에서는 위 코드중 인증 부분만 잘 떼어내 인증 패키지로 묶어 모듈화 시키는게 좋을 것 같다.</p>

<p>기회가 된다면 다양한 프로바이더의 OAuth2를 인증 체계로 사용하는 하나의 완전한 웹 애플리케이션 튜토리얼을 만들어 보는것도 재밌을 것 같다.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2fgetting-started-with-oauth2-in-go%2f - Go%ec%97%90%ec%84%9c%20OAuth2%20%ec%9d%b8%ec%a6%9d%ed%95%98%ea%b8%b0 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-3">[Go로 구현하는 블록체인] Part 3: 영속성 및 CLI<aside class="dates">May 22 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-2">[Go로 구현하는 블록체인] Part 2: 작업 증명<aside class="dates">May 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-1">[Go로 구현하는 블록체인] Part 1: 기본 프로토타입<aside class="dates">May 17 2018</aside></a>
        </li>
    
        <li>
            <a href="/project-euler-maximum-path-sum">[프로젝트 오일러] 최대 경로합 문제 (18/67)<aside class="dates">May 1 2018</aside></a>
        </li>
    
        <li>
            <a href="/writing-unit-test-for-time-dependent-code">시간에 의존하는 코드를 위한 테스트 작성하기<aside class="dates">Apr 29 2018</aside></a>
        </li>
    
        <li>
            <a href="/translation-the-hidden-components-of-web-caching">[번역] 웹 캐싱의 숨겨진 요소들<aside class="dates">Apr 7 2018</aside></a>
        </li>
    
        <li>
            <a href="/how-to-implement-the-scroll-and-paging-in-python-curses">파이썬 curses에서 스크롤 및 페이징 기능 구현하기<aside class="dates">Mar 6 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-84081627-1', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
