<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">
		
		

		<meta name="generator" content="Hugo 0.26" />
		<title>[번역] 이터레이터와 제너레이터 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [번역] 이터레이터와 제너레이터
                    </h1>
                    <h2 class="headline">
                    Jan 25, 2017 00:00
                    · 4242 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/deep-dive">deep dive</a>
                          
                              <a href="https://mingrammer.com/tags/iterator">iterator</a>
                          
                              <a href="https://mingrammer.com/tags/generator">generator</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#컨테이너-container">컨테이너 (Container)</a></li>
<li><a href="#이터레이블-iterable">이터레이블 (Iterable)</a></li>
<li><a href="#이터레이터-iterator">이터레이터 (Iterator)</a></li>
<li><a href="#제너레이터-generator">제너레이터 (Generator)</a>
<ul>
<li><a href="#제너레이터의-타입">제너레이터의 타입</a></li>
</ul></li>
<li><a href="#정리">정리</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<blockquote>
<p><a href="http://nvie.com/posts/iterators-vs-generators/">Iterables vs. Iterators. vs Generators</a>를 번역한 글입니다. 모든 이미지는 원문에서 발췌하였습니다.</p>
</blockquote>

<p>나는 파이썬에서 다음과 같은 개념들간의 정확한 차이점에 대해 가끔씩 혼란스러울때가 있다.</p>

<ul>
<li>컨테이너 (Container)</li>
<li>이터레이블 (Iterable)</li>
<li>이터레이터 (Iterator)</li>
<li>제너레이터 (Generator)</li>
<li>제너레이터 표현식 (Generator expression)</li>
<li>{list, set, dict} 컴프리헨션 ({list, set, dict} comprehension)</li>
</ul>

<p>나는 이 포스트를 나중에 레퍼런스로써 참고하기위해 작성하고있다.</p>

<p><img src="/images/2017-01-25-iter-vs-gen-relationships.png" alt="relationships" /></p>

<p><br></p>

<h2 id="컨테이너-container">컨테이너 (Container)</h2>

<p>컨테이너 (Container)컨테이너는 원소들을 가지고 있는 데이터 구조이며 멤버쉽 테스트를 지원한다. (멤버쉽 테스트는 아래에 나온다) 이는 메모리에 상주하는 데이터 구조로, 보통 모든 원소값을 메모리에 가지고 있다. 파이썬에서 잘 알려진 컨테이너는 다음과 같다:</p>

<ul>
<li><strong>list</strong>, deque, &hellip;</li>
<li><strong>set</strong>, frozonset, &hellip;</li>
<li><strong>dict</strong>, defaultdict, OrderedDict, Counter, &hellip;</li>
<li><strong>tuple</strong>, namedtuple, &hellip;</li>
<li><strong>str</strong></li>
</ul>

<p>컨테이너는 실세계의 컨테이너(박스, 컵보드, 집, 화물 등)처럼 생각하면 되기에 다루기가 쉽다.</p>

<p>기술적으로, 어떤 객체가 특정한 원소를 포함하고 있는지 아닌지를 판단할 수 있으면 컨테이너라고 한다. 다음과 같이 리스트, 셋 또는 튜플에 대해 멤버쉽 테스트를 할 수 있다:</p>

<pre><code class="language-python">&gt;&gt;&gt; assert 1 in [1, 2, 3]     # lists
&gt;&gt;&gt; assert 4 not in [1, 2, 3]
&gt;&gt;&gt; assert 1 in {1, 2, 3}     # sets
&gt;&gt;&gt; assert 4 not in {1, 2, 3}
&gt;&gt;&gt; assert 1 in (1, 2, 3)     # tuples
&gt;&gt;&gt; assert 4 not in (1, 2, 3)
</code></pre>

<p>딕셔너리 멤버쉽은 키 값을 체크한다:</p>

<pre><code class="language-python">&gt;&gt;&gt; d = {1: 'foo', 2: 'bar', 3: 'qux'}
&gt;&gt;&gt; assert 1 in d
&gt;&gt;&gt; assert 4 not in d
&gt;&gt;&gt; assert 'foo' not in d  # 'foo'는 딕셔너리의 키값이 아니다
</code></pre>

<p>마지막으로 문자열에는 부분문자열이 &ldquo;포함&rdquo;되어 있는지를 체크할 수 있다:</p>

<pre><code class="language-python">&gt;&gt;&gt; s = 'foobar'
&gt;&gt;&gt; assert 'b' in s
&gt;&gt;&gt; assert 'x' not in s
&gt;&gt;&gt; assert 'foo' in s  # 문자열은 부분문자열을 모두 &quot;포함&quot;하고 있다
</code></pre>

<p>마지막 예제는 조금 이상하지만, 이는 컨테이너 인터페이스가 어떻게 객체를 불투명하게 렌더링 하는지를 보여준다. 문자열은 모든 부분문자열들의 리터럴 복사본을 메모리에 저장하고 있지는 않지만, 의심의 여지 없이 위와 같이 사용할 수 있다.</p>

<blockquote>
<p><strong>참고</strong></p>

<p>대부분의 컨테이너가 자신이 포함하고 있는 모든 원소들을 생성하는 방법을 제공하지만, 이 기능은 이를 컨테이너로 만드는게 아니라 이터레이블로 만듭니다. (잠시 후에 살펴본다)</p>

<p>모든 컨테이너가 이터레이블할 필요는 없다. 이의 한 예는 <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>이다. 이와 같은 확률적 데이터 구조는 특정 원소를 포함하고 있는지는 판단할 수 있지만, 각각의 개별 원소를 반환하지는 못한다.</p>
</blockquote>

<p><br></p>

<h2 id="이터레이블-iterable">이터레이블 (Iterable)</h2>

<p>좀 전에도 언급했듯이, 대부분의 컨테이너는 또한 이터레이블(iterable)하다. 그러나 더 많은 것들 또한 이터레이블하다. 일례로 파일 열기, 소켓 열기등이 있다. 컨테이너가 일반적으로 유한할경우, 이터레이블은 무한한 데이터 소스를 나타낼 수도 있다.</p>

<p><strong>이터레이블(iterable)</strong>은 반드시 데이터 구조일 필요는 없으며 <strong>이터레이터(iterator)</strong>(모든 원소를 반환할 목적으로)를 반환할 수 있는 모든 객체가 가능하다. 이는 조금 어색하게 들릴 수 있지만, 이터레이블과 이터레이터 사이에는 중요한 차이점이 있다. 다음 예시를 보자:</p>

<pre><code class="language-python">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = iter(x)
&gt;&gt;&gt; z = iter(x)
&gt;&gt;&gt; next(y)
1
&gt;&gt;&gt; next(y)
2
&gt;&gt;&gt; next(z)
1
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(y)
&lt;class 'list_iterator'&gt;
</code></pre>

<p>여기서, <strong>y</strong>와 <strong>z</strong>는 각각 이터레이블 <strong>x</strong>로부터 값을 생성해내는 이터레이터의 인스턴스이고 <strong>x</strong>는 이터레이블이다. <strong>y</strong>와 <strong>z</strong>는 예시에서 볼 수 있듯이 상태를 가진다. 이 예시에서, <strong>x</strong>는 데이터 구조(리스트)지만, 이는 필수 요건은 아니다.</p>

<blockquote>
<p>참고</p>

<p>종종, 실용적인 이유로, 이터레이블 클래스는 같은 클래스에 <strong><strong>iter</strong>()</strong>와 <strong><strong>next</strong>()</strong>를 모두 구현하며, 클래스를 이터레이블과 자체 이터레이터로 만들어주는 <strong>self</strong>를 반환하는 <strong><strong>iter</strong>()</strong>를 갖는다. 그러나 이터레이터로 다른 객체를 반환해도 전혀 상관이 없다.</p>
</blockquote>

<p>마지막으로, 다음과 같이 작성하면:</p>

<pre><code class="language-python">x = [1, 2, 3]
for elem in x:
    ...
</code></pre>

<p>실제로 다음과 같은 일이 일어난다:</p>

<p><img src="/images/2017-01-25-iter-vs-gen-iterable-vs-iterator.png" alt="iterable-vs-iterator" /></p>

<p>파이썬 코드를 디스어셈블링(어셈블리 수준으로 코드를 해부함) 해보면 <strong>iter(x)</strong>를 실행시키는데 필요한 <strong>GET_ITER</strong>를 호출하고 있음을 볼 수 있다. <strong>FOR_ITER</strong>는 모든 원소를 반복적으로 가져오기 위해 <strong>next()</strong>를 호출하는것과 동일한 일을 수행하는 명령어지만, 인터프리터에서 속도에 최적화 되어있기 때문에 바이트 코드 명령어에서는 보이지 않는다.</p>

<pre><code class="language-python">&gt;&gt;&gt; import dis
&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; dis.dis('for _ in x: pass')
  1 		 0 SETUP_LOOP        14 (to 17)
    		 3 LOAD_NAME          0 (x)
	     	 6 GET_ITER
	  &gt;&gt; 	 7 FOR_ITER           6 (to 16)
	     	10 STORE_NAME         1 (_)
	     	13 JUMP_ABSOLUTE      7
	  &gt;&gt;   	16 POP_BLOCK
	  &gt;&gt;   	17 LOAD_CONST         0 (None)         
	     	20 RETURN_VALUE   
</code></pre>

<p><br></p>

<h2 id="이터레이터-iterator">이터레이터 (Iterator)</h2>

<p>그럼 <strong>이터레이터(iterator)</strong>란 무엇인가? 이는 <strong>next()</strong>를 호출할 때 다음값을 생성해내는 상태를 가진 헬퍼 객체이다. <strong><strong>next</strong>()</strong>를 가진 모든 객체는 이터레이터이다. 값을 생성해내는 방법과는 무관하다.</p>

<p>즉 이터레이터는 값 생성기이다. &ldquo;다음&rdquo;값을 요청할 때마다 내부 상태를 유지하고 있기 때문에 다음값을 계산하는 방법을 알고있다.</p>

<p>이터레이터의 예시는 셀 수 없이 많다. <strong>itertools</strong>의 모든 함수는 이터레이터를 반환한다. 일부는 무한 시퀀스를 생성한다:</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; counter = count(start=13)
&gt;&gt;&gt; next(counter)
13
&gt;&gt;&gt; next(counter)
14
</code></pre>

<p>일부는 유한 시퀀스로부터 무한 시퀀스를 생성한다:</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue'])
&gt;&gt;&gt; next(colors)
'red'
&gt;&gt;&gt; next(colors)
'white'
&gt;&gt;&gt; next(colors)
'blue'
&gt;&gt;&gt; next(colors)
'red'
</code></pre>

<p>일부는 무한 시퀀스로부터 유한 시퀀스를 생성한다:</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue'])  # 무한
&gt;&gt;&gt; limited = islice(colors, 0, 4)            # 유한
&gt;&gt;&gt; for x in limited:						# 따라서 for 루프에 사용하기에 안전하다
... 	print(x)
red
white
blue
red
</code></pre>

<p>이터레이터의 내부 구조를 좀 더 잘 이해하기위해, 피보나치수를 생성하는 이터레이터를 만들어보자:</p>

<pre><code class="language-python">&gt;&gt;&gt; class fib:
...     def __init__(self):
...         self.prev = 0
...         self.curr = 1
...
...     def __iter__(self):
...         return self
...
...     def __next__(self):
...         value = self.curr
...         self.curr += self.prev
...         self.prev = value
...         return value
&gt;&gt;&gt; f = fib()
&gt;&gt;&gt; list(islice(f, 0, 10))
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>

<p>참고로 이 클래스는 이터레이블 (<strong><strong>iter</strong>()</strong> 메서드를 사용하므로)이자 자체 이터레이터 (<strong><strong>next</strong>()</strong> 메서드를 가지므로)이다.</p>

<p>이터레이터 내의 상태는 <strong>prev</strong>와 <strong>curr</strong> 인스턴스값으로 유지되고 있으며, 이터레이터를 호출하는 서브 시퀀스에 사용된다. <strong>next()</strong>를 호출할때마다 두 가지 중요한 작업이 수행된다:</p>

<ol>
<li>다음 <strong>next()</strong> 호출을 위해 상태를 변경한다</li>
<li>현재 호출에 대한 결괏값을 생성한다</li>
</ol>

<blockquote>
<p><strong>핵심 아이디어: 게으른 팩토리 (a lazy factory)</strong></p>

<p>바깥에서보면 이터레이터는 값을 요청할때까지 유휴(idle) 상태인 게으른 팩토리처럼 보인다. 이는 하나의 값을 생성한 후에 다시 유휴 상태가 된다.</p>
</blockquote>

<p><br></p>

<h2 id="제너레이터-generator">제너레이터 (Generator)</h2>

<p>드디어, 우리의 목적지에 도착했다! 제너레이터는 내가 파이썬에서 정말 좋아하는 기능이다. 제너레이터는 특별한 종류의 이터레이터이다. (우아한 종류의)</p>

<p>제너레이터를 사용하면 위 예시의 피보나치 시퀀스 이터레이터와 같은 이터레이터를 만들 수 있지만,  <strong><strong>iter</strong>()</strong>와 <strong><strong>next</strong>()</strong> 메서드로 클래스를 작성하는걸 피하는 우아하고 간결한 문법을 사용한다.</p>

<p>명쾌하게 정리하면 다음과 같다:</p>

<ul>
<li>모든 제너레이터는 이터레이터이다 (그 반대는 성립하지 않는다)</li>
<li>모든 제너레이터는 게으른 팩토리이다 (즉, 값을 그 때 그 때 생성한다)</li>
</ul>

<p>다음은 제너레이터로 작성된 동일한 피보나치 시퀀스 팩토리이다:</p>

<pre><code class="language-python">&gt;&gt;&gt; def fib():
...     prev, curr = 0, 1
...     while True:
...         yield curr
...         prev, curr = curr, prev + curr
...
&gt;&gt;&gt; f = fib()
&gt;&gt;&gt; list(islice(f, 0, 10))
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>

<p>와우, 우아하지 않은가? 이 아름다움을 만들어주는 매직 키워드를 보라:</p>

<pre><code>yield
</code></pre>

<p>무슨일이 일어나고 있는지 차근 차근 살펴보자: 우선, <strong>fib</strong>가 일반적인 파이썬 함수로써 정의되었음을 볼 수 있다. 특별할게 없다. 그러나, 함수 몸체(body)에 <strong>return</strong> 키워드가 없음을 주목하라. 이 함수의 반환값을 제너레이터이다. (이터레이터이고 팩토리이자 상태를 가진 헬퍼 객체)</p>

<p><code>f = fib()</code>가 호출될 때, 제너레이터(팩토리)가 인스턴스화되어 반환된다. 이 시점에선 아무런 코드도 실행되지 않는다: 제너레이터는 초기에 유휴 상태에서 시작한다. 좀 더 명확하게는, <code>prev, curr = 0, 1</code>은 아직 실행되지 않았다.</p>

<p>그 다음에 제너레이터 인스턴스는 <strong>islice()</strong>로 래핑되었다. 이것 자체도 또한 이터레이터이므로 초기엔 유휴 상태이다. 여전히 아무일도 일어나지 않았다.</p>

<p>그 다음엔 이터레이터가 <strong>list()</strong>로 래핑되었는데 이는 인자들을 모두 소비하여 리스트를 만들어낸다. 이를 위해, <strong>list</strong>는 <strong>islice()</strong> 인스턴스에서 <strong>next()</strong>를 호출하기 시작하며 또한 <strong>islice</strong>는 <strong>f</strong> 인스턴스에서 <strong>next()</strong>를 호출하기 시작한다.</p>

<p>하나씩 짚어보자. 첫번째 호출시, 마침내 코드가 조금씩 실행된다: <code>prev, curr = 0, 1</code>이 실행되고, <code>while True</code> 루프에 들어가 <code>yield curr</code> 구문을 만난다. 이는 현재 <strong>curr</strong> 변수에 저장된 값을 생성하고나서 다시 유휴 상태로 돌아간다.</p>

<p>이 값은 <strong>islice()</strong> 래퍼에 전달되어 생성되고 (아직 10번째 값을 지나지 않았으므로), <strong>list</strong>는 이제 값 <strong>1</strong>을 리스트에 추가할 수 있다.</p>

<p>다음으로, 이는 다음값을 <strong>islice()</strong>에 요청하고, <strong>islice</strong>는 <strong>f</strong>에 다음값을 요청하는데, 이 때 <strong>f</strong>는 이전 상태로부터의 유휴 상태가 풀리며 <code>prev, curr = curr, prev + curr</code>를 이어서 실행한다. 다시 <code>while loop</code>의 다음 반복에 재진입하여, <code>yield curr</code> 구문을 만나 <code>curr</code>의 다음값을 반환한다.</p>

<p>이 작업은 결과 리스트가 10개의 원소를 가질때까지 계속 진행되며 <strong>list()</strong>가 <strong>islice()</strong>에 11번째 값을 요청할때, <strong>islice()</strong>는 마지막에 도달했음을 가리키는 <code>StopIteration</code> 익셉션을 발생시키고 리스트는 결괏값을 반환한다: 첫 10개의 피보나치 수들을 포함하는 리스트. 참고로 제너레이터는 11번째 <strong>next()</strong> 호출을 받지 않는다. 실제로, 이는 다시 사용되지 않으며, 나중에 가비지 컬렉션에 의해 수집된다.</p>

<h3 id="제너레이터의-타입">제너레이터의 타입</h3>

<p>파이썬에는 두 가지 타입의 제너레이터가 있다: 제너레이터 <strong>함수(functions)</strong>와 제너레이터 <strong>표현식(expressions)</strong>. 제너레이터 함수는 몸체에 <strong>yield</strong> 키워드가 나타나는 모든 함수들이다. 우리는 아까 이의 예시를 보았다. <strong>yield</strong> 키워드가 있는것만으로도 함수를 제너레이터 함수로 만들기에 충분한 조건이다.</p>

<p>또 다른 타입의 제너레이터는 리스트 컴프리헨션 (list comprehension)과 동일한 제너레이터이다. 이 구문은 제한된 사용 케이스에 대해 매우 우아하다.</p>

<p>제곱수의 리스트를 만들기 위해 이 구문을 사용한다고 해보자:</p>

<pre><code class="language-python">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; [x * x for x in numbers]
[1, 4, 9, 16, 25, 36]
</code></pre>

<p>셋 컴프리헨션으로도 동일한 일을 할 수 있다:</p>

<pre><code class="language-python">&gt;&gt;&gt; {x * x for x in numbers}
{1, 4, 36, 9, 16, 25}
</code></pre>

<p>또는 딕셔너리 컴프리헨션에서도 마찬가지이다:</p>

<pre><code class="language-python">&gt;&gt;&gt; {x: x * x for x in numbers}
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
</code></pre>

<p>하지만 제너레이터 표현식 또한 사용할 수 있다 (유의: 이는 튜플 컴프리헨션이 <em>아니다</em>)</p>

<pre><code class="language-python">&gt;&gt;&gt; lazy_squares = (x * x for x in numbers)
&gt;&gt;&gt; lazy_squares
&lt;generator object &lt;genexpr&gt; at 0x10d1f5510&gt;
&gt;&gt;&gt; next(lazy_squares)
1
&gt;&gt;&gt; list(lazy_squares)
[4, 9, 16, 25, 36]
</code></pre>

<p>참고로, <strong>next()</strong>로 <strong>lazy_squares</strong>에서 첫번째 값을 읽었으므로, 상태는 &ldquo;두번째&rdquo; 항목에 위치한다. 따라서 <strong>list()</strong>를 호출하여 전체값을 받아올때는, 제곱수의 일부분만 반환한다. (이는 단지 게으른 행동을 보여준다.) 이는 위의 다른 예제와 마찬가지로 제너레이터 (그리고 따라서, 이터레이터)이다.</p>

<p><br></p>

<h2 id="정리">정리</h2>

<p>제너레이터는 놀랍도록 강력한 프로그래밍 구조이다. 이는 몇가지 중간 변수와 데이터 구조를 가지고 스트리밍 코드를 작성할 수 있게 해준다. 게다가, 이는 메모리/CPU 효율이 더 좋다. 마지막으로, 이는 코드의 라인수를 줄여주는 경향도 있다.</p>

<p>제너레이터를 시작하는 팁: 여러분의 코드에서 다음과 같이 할 수 있는 부분을 찾아보라:</p>

<pre><code class="language-python">def something():
    result = []
    for ... in ...:
        result.append(x)
   	return result
</code></pre>

<p>이를 다음으로 교체한다:</p>

<pre><code class="language-python">def iter_sometime():
    for ... in ...:
        yield x
        
# def something()  # 정말로 리스트 구조가 필요할때만
#     return list(iter_something())
</code></pre>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2ftranslation-iterators-vs-generators%2f - %5b%eb%b2%88%ec%97%ad%5d%20%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0%ec%99%80%20%ec%a0%9c%eb%84%88%eb%a0%88%ec%9d%b4%ed%84%b0 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/cgo-cross-compile-for-mac-for-linux">맥에서 리눅스로 CGO 라이브러리 크로스 컴파일하기<aside class="dates">Dec 11 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-cpython-internals-arbitrary-precision-integer-implementation">[번역] 파이썬 내부 동작 원리: 임의 정밀도의 정수 구현<aside class="dates">Oct 10 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-10-common-software-architectural-patterns-in-a-nutshell">[번역] 10가지 소프트웨어 아키텍처 패턴 요약<aside class="dates">Sep 10 2017</aside></a>
        </li>
    
        <li>
            <a href="/setup-the-python-development-environment-with-pycharm-and-docker">PyCharm &#43; Docker로 파이썬 개발환경 셋업하기 (Dockerization)<aside class="dates">Jul 14 2017</aside></a>
        </li>
    
        <li>
            <a href="/introduce-comprehension-of-python">파이썬의 Comprehension 소개<aside class="dates">Jun 14 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-the-truth-is-in-the-code">[번역] 진실은 코드에 있다<aside class="dates">May 7 2017</aside></a>
        </li>
    
        <li>
            <a href="/tips-of-using-comma-in-python">파이썬의 Comma(,) 사용팁<aside class="dates">Apr 26 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-the-mathematics-of-machine-learning">[번역] 머신러닝 속 수학<aside class="dates">Apr 24 2017</aside></a>
        </li>
    
        <li>
            <a href="/translation-13-simple-rules-for-good-coding">[번역] 좋은 코딩을 위한 13 가지 간단한 규칙<aside class="dates">Apr 2 2017</aside></a>
        </li>
    
        <li>
            <a href="/understanding-the-asterisk-of-python">파이썬의 Asterisk(*) 이해하기<aside class="dates">Mar 20 2017</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-84081627-1', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
