<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="mingrammer">
		<meta name="description" content="mingrammer&#39;s dev logs">

		
		<meta property="og:title" content="[번역] 이터레이터와 제너레이터" />
<meta property="og:description" content="Iterables vs. Iterators. vs Generators를 번역한 글입니다. 모든 이미지는 원문에서 발췌하였습니다. 나는 파이썬에서 다음과 같은 개념들간의 정확한 차이점에 대해 가끔씩" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mingrammer.com/translation-iterators-vs-generators/" />
<meta property="article:published_time" content="2017-01-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-01-25T00:00:00+00:00" />

		

		<meta name="generator" content="Hugo 0.69.0" />
		<title>[번역] 이터레이터와 제너레이터 &middot; mingrammer&#39;s note</title>
		<link rel="shortcut icon" href="https://mingrammer.com/images/favicon.ico">
		<link rel="stylesheet" href="https://mingrammer.com/css/style.css">
		<link rel="stylesheet" href="https://mingrammer.com/css/highlight.css">

		
		<link rel="stylesheet" href="https://mingrammer.com/css/font-awesome.min.css">
		

		
		<link href="https://mingrammer.com/index.xml" rel="alternate" type="application/rss+xml" title="mingrammer&#39;s note" />
		

		
		<link rel="stylesheet" href="https://mingrammer.com/css/custom.css">
		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://mingrammer.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://mingrammer.com/post'>Archive</a>
	<a href='https://mingrammer.com/categories'>Categories</a>
	<a href='https://mingrammer.com/tags'>Tags</a>
	<a href='https://mingrammer.com/about'>About</a>

	

	
	<a class="cta" href="https://mingrammer.com/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [번역] 이터레이터와 제너레이터
                    </h1>
                    <h2 class="headline">
                    Jan 25, 2017 00:00
                    · 4346 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://mingrammer.com/tags/deep-dive">deep dive</a>
                          
                              <a href="https://mingrammer.com/tags/iterator">iterator</a>
                          
                              <a href="https://mingrammer.com/tags/generator">generator</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
  <ul>
    <li><a href="#컨테이너-container">컨테이너 (Container)</a></li>
    <li><a href="#이터레이블-iterable">이터레이블 (Iterable)</a></li>
    <li><a href="#이터레이터-iterator">이터레이터 (Iterator)</a></li>
    <li><a href="#제너레이터-generator">제너레이터 (Generator)</a>
      <ul>
        <li><a href="#제너레이터의-타입">제너레이터의 타입</a></li>
      </ul>
    </li>
    <li><a href="#정리">정리</a></li>
  </ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <blockquote>
<p><a href="http://nvie.com/posts/iterators-vs-generators/">Iterables vs. Iterators. vs Generators</a>를 번역한 글입니다. 모든 이미지는 원문에서 발췌하였습니다.</p>
</blockquote>
<p>나는 파이썬에서 다음과 같은 개념들간의 정확한 차이점에 대해 가끔씩 혼란스러울때가 있다.</p>
<ul>
<li>컨테이너 (Container)</li>
<li>이터레이블 (Iterable)</li>
<li>이터레이터 (Iterator)</li>
<li>제너레이터 (Generator)</li>
<li>제너레이터 표현식 (Generator expression)</li>
<li>{list, set, dict} 컴프리헨션 ({list, set, dict} comprehension)</li>
</ul>
<p>나는 이 포스트를 나중에 레퍼런스로써 참고하기위해 작성하고있다.</p>
<p><img src="/images/2017-01-25-iter-vs-gen-relationships.png" alt="relationships"></p>
<!-- raw HTML omitted -->
<h1 id="컨테이너-container">컨테이너 (Container)</h1>
<p>컨테이너(Container)는 원소들을 가지고 있는 데이터 구조이며 멤버쉽 테스트를 지원한다. (멤버쉽 테스트는 아래에 나온다) 이는 메모리에 상주하는 데이터 구조로, 보통 모든 원소값을 메모리에 가지고 있다. 파이썬에서 잘 알려진 컨테이너는 다음과 같다:</p>
<ul>
<li><strong>list</strong>, deque, &hellip;</li>
<li><strong>set</strong>, frozonset, &hellip;</li>
<li><strong>dict</strong>, defaultdict, OrderedDict, Counter, &hellip;</li>
<li><strong>tuple</strong>, namedtuple, &hellip;</li>
<li><strong>str</strong></li>
</ul>
<p>컨테이너는 실세계의 컨테이너(박스, 컵보드, 집, 화물 등)처럼 생각하면 되기에 다루기가 쉽다.</p>
<p>기술적으로, 어떤 객체가 특정한 원소를 포함하고 있는지 아닌지를 판단할 수 있으면 컨테이너라고 한다. 다음과 같이 리스트, 셋 또는 튜플에 대해 멤버쉽 테스트를 할 수 있다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>     <span class="c1"># lists</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>     <span class="c1"># sets</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>     <span class="c1"># tuples</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><p>딕셔너리 멤버쉽은 키 값을 체크한다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;qux&#39;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">d</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="s1">&#39;foo&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span>  <span class="c1"># &#39;foo&#39;는 딕셔너리의 키값이 아니다</span>
</code></pre></div><p>마지막으로 문자열에는 부분문자열이 &ldquo;포함&quot;되어 있는지를 체크할 수 있다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;foobar&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">s</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="s1">&#39;x&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="s1">&#39;foo&#39;</span> <span class="ow">in</span> <span class="n">s</span>  <span class="c1"># 문자열은 부분문자열을 모두 &#34;포함&#34;하고 있다</span>
</code></pre></div><p>마지막 예제는 조금 이상하지만, 이는 컨테이너 인터페이스가 어떻게 객체를 불투명하게 렌더링 하는지를 보여준다. 문자열은 모든 부분문자열들의 리터럴 복사본을 메모리에 저장하고 있지는 않지만, 의심의 여지 없이 위와 같이 사용할 수 있다.</p>
<blockquote>
<p><strong>참고</strong></p>
<p>대부분의 컨테이너가 자신이 포함하고 있는 모든 원소들을 생성하는 방법을 제공하지만, 이 기능은 이를 컨테이너로 만드는게 아니라 이터레이블로 만듭니다. (잠시 후에 살펴본다)</p>
<p>모든 컨테이너가 이터레이블할 필요는 없다. 이의 한 예는 <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>이다. 이와 같은 확률적 데이터 구조는 특정 원소를 포함하고 있는지는 판단할 수 있지만, 각각의 개별 원소를 반환하지는 못한다.</p>
</blockquote>
<!-- raw HTML omitted -->
<h1 id="이터레이블-iterable">이터레이블 (Iterable)</h1>
<p>좀 전에도 언급했듯이, 대부분의 컨테이너는 또한 이터레이블(iterable)하다. 그러나 더 많은 것들 또한 이터레이블하다. 일례로 파일 열기, 소켓 열기등이 있다. 컨테이너가 일반적으로 유한할경우, 이터레이블은 무한한 데이터 소스를 나타낼 수도 있다.</p>
<p>**이터레이블(iterable)**은 반드시 데이터 구조일 필요는 없으며 <strong>이터레이터(iterator)</strong>(모든 원소를 반환할 목적으로)를 반환할 수 있는 모든 객체가 가능하다. 이는 조금 어색하게 들릴 수 있지만, 이터레이블과 이터레이터 사이에는 중요한 차이점이 있다. 다음 예시를 보자:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">list</span><span class="s1">&#39;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">list_iterator</span><span class="s1">&#39;&gt;</span>
</code></pre></div><p>여기서, <strong>y</strong>와 <strong>z</strong>는 각각 이터레이블 <strong>x</strong>로부터 값을 생성해내는 이터레이터의 인스턴스이고 <strong>x</strong>는 이터레이블이다. <strong>y</strong>와 <strong>z</strong>는 예시에서 볼 수 있듯이 상태를 가진다. 이 예시에서, <strong>x</strong>는 데이터 구조(리스트)지만, 이는 필수 요건은 아니다.</p>
<blockquote>
<p>참고</p>
<p>종종, 실용적인 이유로, 이터레이블 클래스는 같은 클래스에 **<strong>iter</strong>()**와 **<strong>next</strong>()**를 모두 구현하며, 클래스를 이터레이블과 자체 이터레이터로 만들어주는 <strong>self</strong>를 반환하는 **<strong>iter</strong>()**를 갖는다. 그러나 이터레이터로 다른 객체를 반환해도 전혀 상관이 없다.</p>
</blockquote>
<p>마지막으로, 다음과 같이 작성하면:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
    <span class="o">...</span>
</code></pre></div><p>실제로 다음과 같은 일이 일어난다:</p>
<p><img src="/images/2017-01-25-iter-vs-gen-iterable-vs-iterator.png" alt="iterable-vs-iterator"></p>
<p>파이썬 코드를 디스어셈블링(어셈블리 수준으로 코드를 해부함) 해보면 **iter(x)**를 실행시키는데 필요한 <strong>GET_ITER</strong>를 호출하고 있음을 볼 수 있다. <strong>FOR_ITER</strong>는 모든 원소를 반복적으로 가져오기 위해 **next()**를 호출하는것과 동일한 일을 수행하는 명령어지만, 인터프리터에서 속도에 최적화 되어있기 때문에 바이트 코드 명령어에서는 보이지 않는다.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="s1">&#39;for _ in x: pass&#39;</span><span class="p">)</span>
  <span class="mi">1</span> 		 <span class="mi">0</span> <span class="n">SETUP_LOOP</span>        <span class="mi">14</span> <span class="p">(</span><span class="n">to</span> <span class="mi">17</span><span class="p">)</span>
    		 <span class="mi">3</span> <span class="n">LOAD_NAME</span>          <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
	     	 <span class="mi">6</span> <span class="n">GET_ITER</span>
	  <span class="o">&gt;&gt;</span> 	 <span class="mi">7</span> <span class="n">FOR_ITER</span>           <span class="mi">6</span> <span class="p">(</span><span class="n">to</span> <span class="mi">16</span><span class="p">)</span>
	     	<span class="mi">10</span> <span class="n">STORE_NAME</span>         <span class="mi">1</span> <span class="p">(</span><span class="n">_</span><span class="p">)</span>
	     	<span class="mi">13</span> <span class="n">JUMP_ABSOLUTE</span>      <span class="mi">7</span>
	  <span class="o">&gt;&gt;</span>   	<span class="mi">16</span> <span class="n">POP_BLOCK</span>
	  <span class="o">&gt;&gt;</span>   	<span class="mi">17</span> <span class="n">LOAD_CONST</span>         <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>         
	     	<span class="mi">20</span> <span class="n">RETURN_VALUE</span>   
</code></pre></div><!-- raw HTML omitted -->
<h1 id="이터레이터-iterator">이터레이터 (Iterator)</h1>
<p>그럼 **이터레이터(iterator)**란 무엇인가? 이는 **next()**를 호출할 때 다음값을 생성해내는 상태를 가진 헬퍼 객체이다. **<strong>next</strong>()**를 가진 모든 객체는 이터레이터이다. 값을 생성해내는 방법과는 무관하다.</p>
<p>즉 이터레이터는 값 생성기이다. &ldquo;다음&quot;값을 요청할 때마다 내부 상태를 유지하고 있기 때문에 다음값을 계산하는 방법을 알고있다.</p>
<p>이터레이터의 예시는 셀 수 없이 많다. <strong>itertools</strong>의 모든 함수는 이터레이터를 반환한다. 일부는 무한 시퀀스를 생성한다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="mi">13</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="mi">14</span>
</code></pre></div><p>일부는 유한 시퀀스로부터 무한 시퀀스를 생성한다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">cycle</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">colors</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
<span class="s1">&#39;red&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
<span class="s1">&#39;white&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
<span class="s1">&#39;blue&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
<span class="s1">&#39;red&#39;</span>
</code></pre></div><p>일부는 무한 시퀀스로부터 유한 시퀀스를 생성한다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">colors</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">])</span>  <span class="c1"># 무한</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">limited</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>            <span class="c1"># 유한</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">limited</span><span class="p">:</span>						<span class="c1"># 따라서 for 루프에 사용하기에 안전하다</span>
<span class="o">...</span> 	<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">red</span>
<span class="n">white</span>
<span class="n">blue</span>
<span class="n">red</span>
</code></pre></div><p>이터레이터의 내부 구조를 좀 더 잘 이해하기위해, 피보나치수를 생성하는 이터레이터를 만들어보자:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">fib</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>         <span class="k">return</span> <span class="bp">self</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>         <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr</span>
<span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">curr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span>
<span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">value</span>
<span class="o">...</span>         <span class="k">return</span> <span class="n">value</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fib</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">55</span><span class="p">]</span>
</code></pre></div><p>참고로 이 클래스는 이터레이블(<strong><strong>iter</strong>()</strong> 메서드를 사용하므로)이자 자체 이터레이터(<strong><strong>next</strong>()</strong> 메서드를 가지므로)이다.</p>
<p>이터레이터 내의 상태는 <strong>prev</strong>와 <strong>curr</strong> 인스턴스값으로 유지되고 있으며, 이터레이터를 호출하는 서브 시퀀스에 사용된다. **next()**를 호출할때마다 두 가지 중요한 작업이 수행된다:</p>
<ol>
<li>다음 <strong>next()</strong> 호출을 위해 상태를 변경한다</li>
<li>현재 호출에 대한 결괏값을 생성한다</li>
</ol>
<blockquote>
<p><strong>핵심 아이디어: 게으른 팩토리 (a lazy factory)</strong></p>
<p>바깥에서보면 이터레이터는 값을 요청할때까지 유휴(idle) 상태인 게으른 팩토리처럼 보인다. 이는 하나의 값을 생성한 후에 다시 유휴 상태가 된다.</p>
</blockquote>
<!-- raw HTML omitted -->
<h1 id="제너레이터-generator">제너레이터 (Generator)</h1>
<p>드디어, 우리의 목적지에 도착했다! 제너레이터는 내가 파이썬에서 정말 좋아하는 기능이다. 제너레이터는 특별한 종류의 이터레이터이다. (우아한 종류의)</p>
<p>제너레이터를 사용하면 위 예시의 피보나치 시퀀스 이터레이터와 같은 이터레이터를 만들 수 있지만,  **<strong>iter</strong>()**와 <strong><strong>next</strong>()</strong> 메서드로 클래스를 작성하는걸 피하는 우아하고 간결한 문법을 사용한다.</p>
<p>명쾌하게 정리하면 다음과 같다:</p>
<ul>
<li>모든 제너레이터는 이터레이터이다 (그 반대는 성립하지 않는다)</li>
<li>모든 제너레이터는 게으른 팩토리이다 (즉, 값을 그 때 그 때 생성한다)</li>
</ul>
<p>다음은 제너레이터로 작성된 동일한 피보나치 시퀀스 팩토리이다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fib</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">yield</span> <span class="n">curr</span>
<span class="o">...</span>         <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">curr</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fib</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">55</span><span class="p">]</span>
</code></pre></div><p>와우, 우아하지 않은가? 이 아름다움을 만들어주는 매직 키워드를 보라:</p>
<pre><code>yield
</code></pre><p>무슨일이 일어나고 있는지 차근 차근 살펴보자: 우선, <strong>fib</strong>가 일반적인 파이썬 함수로써 정의되었음을 볼 수 있다. 특별할게 없다. 그러나, 함수 몸체(body)에 <strong>return</strong> 키워드가 없음을 주목하라. 이 함수의 반환값을 제너레이터이다. (이터레이터이고 팩토리이자 상태를 가진 헬퍼 객체)</p>
<p><code>f = fib()</code>가 호출될 때, 제너레이터(팩토리)가 인스턴스화되어 반환된다. 이 시점에선 아무런 코드도 실행되지 않는다: 제너레이터는 초기에 유휴 상태에서 시작한다. 좀 더 명확하게는, <code>prev, curr = 0, 1</code>은 아직 실행되지 않았다.</p>
<p>그 다음에 제너레이터 인스턴스는 **islice()**로 래핑되었다. 이것 자체도 또한 이터레이터이므로 초기엔 유휴 상태이다. 여전히 아무일도 일어나지 않았다.</p>
<p>그 다음엔 이터레이터가 **list()**로 래핑되었는데 이는 인자들을 모두 소비하여 리스트를 만들어낸다. 이를 위해, <strong>list</strong>는 <strong>islice()</strong> 인스턴스에서 **next()**를 호출하기 시작하며 또한 <strong>islice</strong>는 <strong>f</strong> 인스턴스에서 **next()**를 호출하기 시작한다.</p>
<p>하나씩 짚어보자. 첫번째 호출시, 마침내 코드가 조금씩 실행된다: <code>prev, curr = 0, 1</code>이 실행되고, <code>while True</code> 루프에 들어가 <code>yield curr</code> 구문을 만난다. 이는 현재 <strong>curr</strong> 변수에 저장된 값을 생성하고나서 다시 유휴 상태로 돌아간다.</p>
<p>이 값은 <strong>islice()</strong> 래퍼에 전달되어 생성되고 (아직 10번째 값을 지나지 않았으므로), <strong>list</strong>는 이제 값 <strong>1</strong>을 리스트에 추가할 수 있다.</p>
<p>다음으로, 이는 다음값을 **islice()**에 요청하고, <strong>islice</strong>는 <strong>f</strong>에 다음값을 요청하는데, 이 때 <strong>f</strong>는 이전 상태로부터의 유휴 상태가 풀리며 <code>prev, curr = curr, prev + curr</code>를 이어서 실행한다. 다시 <code>while loop</code>의 다음 반복에 재진입하여, <code>yield curr</code> 구문을 만나 <code>curr</code>의 다음값을 반환한다.</p>
<p>이 작업은 결과 리스트가 10개의 원소를 가질때까지 계속 진행되며 **list()**가 **islice()**에 11번째 값을 요청할때, **islice()**는 마지막에 도달했음을 가리키는 <code>StopIteration</code> 익셉션을 발생시키고 리스트는 결괏값을 반환한다: 첫 10개의 피보나치 수들을 포함하는 리스트. 참고로 제너레이터는 11번째 <strong>next()</strong> 호출을 받지 않는다. 실제로, 이는 다시 사용되지 않으며, 나중에 가비지 컬렉션에 의해 수집된다.</p>
<!-- raw HTML omitted -->
<h2 id="제너레이터의-타입">제너레이터의 타입</h2>
<p>파이썬에는 두 가지 타입의 제너레이터가 있다: 제너레이터 **함수(functions)**와 제너레이터 <strong>표현식(expressions)</strong>. 제너레이터 함수는 몸체에 <strong>yield</strong> 키워드가 나타나는 모든 함수들이다. 우리는 아까 이의 예시를 보았다. <strong>yield</strong> 키워드가 있는것만으로도 함수를 제너레이터 함수로 만들기에 충분한 조건이다.</p>
<p>또 다른 타입의 제너레이터는 리스트 컴프리헨션(list comprehension)과 동일한 제너레이터이다. 이 구문은 제한된 사용 케이스에 대해 매우 우아하다.</p>
<p>제곱수의 리스트를 만들기 위해 이 구문을 사용한다고 해보자:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</code></pre></div><p>셋 컴프리헨션으로도 동일한 일을 할 수 있다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">}</span>
</code></pre></div><p>또는 딕셔너리 컴프리헨션에서도 마찬가지이다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">36</span><span class="p">}</span>
</code></pre></div><p>하지만 제너레이터 표현식 또한 사용할 수 있다 (유의: 이는 튜플 컴프리헨션이 <em>아니다</em>)</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">lazy_squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lazy_squares</span>
<span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x10d1f5510</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">lazy_squares</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">lazy_squares</span><span class="p">)</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</code></pre></div><p>참고로, **next()**로 <strong>lazy_squares</strong>에서 첫번째 값을 읽었으므로, 상태는 &ldquo;두번째&rdquo; 항목에 위치한다. 따라서 **list()**를 호출하여 전체값을 받아올때는, 제곱수의 일부분만 반환한다. (이는 단지 게으른 행동을 보여준다.) 이는 위의 다른 예제와 마찬가지로 제너레이터 (그리고 따라서, 이터레이터)이다.</p>
<!-- raw HTML omitted -->
<h1 id="정리">정리</h1>
<p>제너레이터는 놀랍도록 강력한 프로그래밍 구조이다. 이는 몇가지 중간 변수와 데이터 구조를 가지고 스트리밍 코드를 작성할 수 있게 해준다. 게다가, 이는 메모리/CPU 효율이 더 좋다. 마지막으로, 이는 코드의 라인수를 줄여주는 경향도 있다.</p>
<p>제너레이터를 시작하는 팁: 여러분의 코드에서 다음과 같이 할 수 있는 부분을 찾아보라:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">something</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="o">...</span> <span class="ow">in</span> <span class="o">...</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
   	<span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>이를 다음으로 교체한다:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">iter_sometime</span><span class="p">():</span>
    <span class="k">for</span> <span class="o">...</span> <span class="ow">in</span> <span class="o">...</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
        
<span class="c1"># def something()  # 정말로 리스트 구조가 필요할때만</span>
<span class="c1">#     return list(iter_something())</span>
</code></pre></div>
                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fmingrammer.com%2ftranslation-iterators-vs-generators%2f - %5b%eb%b2%88%ec%97%ad%5d%20%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0%ec%99%80%20%ec%a0%9c%eb%84%88%eb%a0%88%ec%9d%b4%ed%84%b0 by @mingrammer"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
            <div class="adsense">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                
                <ins class="adsbygoogle"
                    style="display:block"
                    data-ad-client="ca-pub-9436560391944255"
                    data-ad-slot="5717491307"
                    data-ad-format="auto"
                    data-full-width-responsive="true"></ins>
                <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>
            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mingrammer-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/go-modules-private-repo">Go 프라이빗 모듈 가져오기<aside class="dates">Apr 18 2020</aside></a>
        </li>
    
        <li>
            <a href="/debugging-containerized-go-app">컨테이너 내부 Go 애플리케이션 디버깅하기<aside class="dates">Feb 13 2020</aside></a>
        </li>
    
        <li>
            <a href="/debug-memory-leak-with-node-heapdump">푸시 데몬 메모리 누수 디버깅하기<aside class="dates">Nov 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/scheduling-cron-job-in-seconds-interval">Cron에서 초단위로 스케줄링하기<aside class="dates">Aug 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/dynamodb-batch-retry-with-exponential-backoff">DynamoDB 배치 작업 재시도 구현 (Exponential Backoff)<aside class="dates">Jun 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/redis-migration">IDC에서 AWS로 Redis 데이터 이전하기<aside class="dates">Feb 1 2019</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-7">[Go로 구현하는 블록체인] Part 7: 네트워크<aside class="dates">Jun 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-6">[Go로 구현하는 블록체인] Part 6: 트랜잭션 2<aside class="dates">Jun 14 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-5">[Go로 구현하는 블록체인] Part 5: 주소<aside class="dates">Jun 6 2018</aside></a>
        </li>
    
        <li>
            <a href="/building-blockchain-in-go-part-4">[Go로 구현하는 블록체인] Part 4: 트랜잭션 1<aside class="dates">May 26 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/mingrammer">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/mingrammer">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/mingrammer">
        <i class="fa fa-twitter-square"></i>
    </a>
    
    
    <a class="symbol" href="https://mingrammer.com/index.xml">
        <i class="fa fa-rss-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> mingrammer
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://mingrammer.com/js/jquery-2.2.4.min.js"></script>
<script src="https://mingrammer.com/js/main.js"></script>
<script src="https://mingrammer.com/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-84081627-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
